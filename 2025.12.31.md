[Day1. 환경설정 & 파이썬 프로그래밍 기초](https://www.notion.so/Day1-2d8efd73348980ecb103f79a78a433d0?pvs=21)

[https://colab.research.google.com/drive/1_1_1jbcWLKgeBjbLecgnlGVSve1b4g3c?usp=sharing](https://colab.research.google.com/drive/1_1_1jbcWLKgeBjbLecgnlGVSve1b4g3c?usp=sharing)

### **1. Git 기본 개념**

- **Git**: 형상 관리 툴로, 프로젝트 내 파일 변경 사항을 추적하고 관리
- **저장소(Repository)**:
    - **로컬 저장소**: 개발자의 컴퓨터에 있는 저장소
    - **원격 저장소(Remote Repository)**: 서버에 있는 저장소(예: GitHub)
- **브랜치(Branch)**: 프로젝트의 독립적인 작업 공간, 기본 브랜치는 'main'

### **2. 기본 Git 명령어**

- `git init`: Git 저장소 초기화, .git 디렉토리 생성
- `git add [파일명]`: 특정 파일의 변경사항을 추적
- `git add .`: 현재 디렉토리의 모든 파일 변경사항 추적
- `git commit -m "메시지"`: 추적 중인 변경사항에 대한 커밋(절취선) 생성
- `git remote add origin [URL]`: 원격 저장소 연결
- `git push origin main`: 로컬 저장소의 변경사항을 원격 저장소에 업로드
- `git pull origin main`: 원격 저장소의 변경사항을 로컬 저장소로 다운로드
- `git status`: 현재 Git 저장소의 상태 확인

### **3. 파일 상태 관리**

- **Untracked**: Git이 아직 추적하지 않는 파일(초록색 표시)
- **Added(A)**: Git이 추적을 시작한 파일
- **Modified(M)**: Git이 이미 추적 중인 파일에서 변경이 발생한 상태
- **Committed**: 변경사항이 Git 저장소에 저장된 상태

### **4. 충돌(Conflict) 관리**

- 충돌은 같은 파일이 서로 다른 곳에서 변경되었을 때 발생
- 충돌 발생 시 "rejected" 에러 메시지와 함께 해결 방법 제안
- 해결 방법:
    1. `git pull`을 통해 원격 저장소의 변경사항 가져오기
    2. 충돌이 발생한 파일 수정(충돌 마커 제거)
    3. 수정한 파일 저장 후 다시 `git add`, `git commit`, `git push` 과정 진행

# **사례/예시**

강의 중 다음과 같은 실습이 진행되었습니다:

1. 저장소 생성 및 파일 추가
    
    text복사
    
    `echo "P406 Git Test" > README.md git init git add README.md`
    
2. 파일 수정 및 커밋
    
    text복사
    
    `# README.md 파일 수정 후 git add . git commit -m "Git 연습, 두 개 파일은 Git 연습에 관한 내용이에요"`
    
3. 원격 저장소 연결 및 푸시
    
    text복사
    
    `git remote add origin <https://github.com/username/repository.git> git push origin main`
    
4. 충돌 상황 재현
    
    - 원격 저장소에서 파일 수정
    - 로컬 저장소에서도 같은 파일 수정
    - `git push` 시도 시 충돌 발생
    - `git pull origin main`으로 변경사항 가져오기
    - 충돌 발생한 파일에서 충돌 마커 확인

# **강조사항**

- 같은 파일을 여러 사람이 동시에 수정하면 충돌이 발생하므로, 가능하면 서로 다른 파일을 작업하는 것이 좋습니다.
- 항상 `git push` 전에 `git pull`을 먼저 실행하여 충돌을 최소화합니다.
- 커밋 메시지는 변경 내용을 명확히 설명하여 다른 사람들이 작업 내용을 이해하기 쉽게 해야 합니다.
- `.git` 디렉토리는 Git이 변경 사항을 추적하는 데 필요한 모든 정보를 포함하므로, 삭제하면 버전 관리 기록이 모두 사라집니다.
- 원격 저장소와 로컬 저장소 중 하나는 비어있는 상태에서 시작하는 것이 충돌을 방지하는 데 도움이 됩니다.

# **1. Git 충돌 해결 방법**

- **충돌 상황**: 로컬과 원격 저장소에서 같은 파일이 다르게 변경되었을 때 발생
- **해결 방법**:
    - 충돌 파일 백업 후 삭제
    - `git pull origin main`으로 원격 변경사항 가져오기
    - `git add .`로 변경사항 추가
    - `git commit -m "메시지"`로 커밋
    - `git push origin main`으로 변경사항 업로드

# **2. 마크다운 문법**

- **제목**: `#` 1~6개 사용 (예: `# 제목1`, `## 제목2`)
- **수평선**: `--` 또는 `**` 또는 `___`
- **강조**:
    - 진하게: `*텍스트**`
    - 기울임: `텍스트*`
    - 취소선: `~~텍스트~~`
    - 진하게+기울임: `**텍스트***`
- **목록**:
    - 순서 없는 목록: , , `+` 사용
    - 순서 있는 목록: `1.`, `2.` 등 사용
    - 들여쓰기: 탭으로 하위 목록 만들기
- **코드**:
    - 인라인 코드: `코드`
    - 코드 블록:  사이에 코드 작성
- **링크**: `[표시 텍스트](URL)`
- **이미지**: `![대체 텍스트](이미지URL)`

# **3. GitHub 프로필 페이지 꾸미기**

- GitHub에서 자신의 아이디와 같은 이름의 저장소 생성
- [README.md](http://README.md) 파일이 자동으로 프로필 페이지로 표시됨
- 마크다운 문법을 활용하여 자기소개, 기술 스택, 프로젝트 등 정보 작성
- GitHub Profile Markdown 생성기 활용 가능
- 방문자 카운터, 뱃지 등 추가 기능 활용

# **사례/예시**

1. **Git 충돌 해결 예시**:
    
    text복사
    
    `git pull origin main git add . git commit -m "delete readme.md" git push origin main`
    
2. **마크다운 사용 예시**:
    
    markdown복사
    
    `# 안녕하세요저는 **개발자**입니다.
    
    ## 기술 스택- Python- Java- JavaScript
    
    ## 프로젝트[프로젝트명](URL)`
    
3. **GitHub 프로필 꾸미기 도구**:
    
    - GitHub Profile Markdown 생성기
    - 뱃지/아이콘: 언어, 툴, 프레임워크 표시

# **강조사항**

- "여러분이 처음부터 코드를 짜는 일은 진짜 없을 거예요. 우리 모두가 부장님이 됐다라고 말씀드렸죠."
- "생성형 AI에게 지시하고 결과를 수정하는 방식으로 개발하되, 결과에 대한 책임은 개발자에게 있음"
- "마크다운 문법을 활용하면 Prompt Engineering 시 LLM 모델에 더 좋은 결과를 얻을 수 있음"
- "코드 작성 시 직접 타이핑하느라 시간 낭비하지 말고, 필요한 코드는 공유받아 활용하는 것이 효율적"
- "Git 충돌 시 가장 안전한 방법은 백업 후 충돌 파일을 삭제하고 동기화하는 것"

### **1. 컴퓨터의 정의**

- 컴퓨터는 입력(input)을 받아 처리하고 출력(output)을 내보내는 기계
- 노트북, 데스크탑뿐만 아니라 입출력 과정을 가진 모든 디바이스(가습기 등)도 넓은 의미에서 컴퓨터에 포함
- 현대의 디바이스들은 입력과 출력이 합쳐진 형태(예: 스마트폰의 터치스크린)로 발전

### **2. 프로그래밍의 의미**

- 프로그래밍: 컴퓨터가 처리할 프로세스를 만드는 과정
- 단순한 코드 작성뿐 아니라 설계, 개발, 에러 수정, 업데이트 등 전체 과정을 포함
- 개발팀은 코딩만 하는 개발자뿐만 아니라 설계, 배포, QA 담당자 등 다양한 역할로 구성됨

### **3. 코딩의 어려움**

- 코딩이 어려운 이유: 인간의 사고방식을 컴퓨터가 이해할 수 있는 방식으로 변환해야 함
- 직관적인 사고(인간)와 논리적이고 단계적인 처리(컴퓨터) 사이의 차이
- 순서(알고리즘)와 데이터 처리 방식(자료 구조)을 명확히 구분하여 작성해야 함

### **4. 순서도(Flowchart)**

- 프로그래밍 과정을 시각화하여 표현하는 도구
- 주요 기호:
    - 시작/종료: 원 또는 붉은 원으로 표시
    - 일반 과정: 동그라미 안에 순서 기재
    - 조건문: 마름모로 표시하여 분기 표현
    - 특수 상황: 진한 테두리나 추가 표시로 구분

### **5. 프로그래밍 언어 종류**

### **저수준 언어 vs 고수준 언어**

- 저수준 언어:
    - 컴퓨터와 더 친화적인 언어
    - 정밀한 문법 요구, 수정이 어려움
    - 적은 메모리로 빠르게 동작 가능
    - 임베디드 개발에 주로 사용
- 고수준 언어:
    - 인간 친화적인 언어(예: 파이썬, 자바)
    - 주어-동사-목적어 형식으로 작성 가능
    - 맥락에 따라 생략 가능(예: print 문에서 주어 생략)
    - 번역 과정에 더 많은 메모리와 시간 필요

### **컴파일 언어 vs 인터프리터 언어**

- 컴파일 언어(예: Java, C):
    - 소스 코드를 한꺼번에 기계어로 변환하여 배포
    - 속도가 빠르고 안정적
    - 에러 발생 시 실행 자체가 불가능
    - 게임, 대규모 애플리케이션 백엔드에 사용
- 인터프리터 언어(예: Python, JavaScript):
    - 한 줄씩 읽어서 실행
    - 수정이 쉽고 즉시 결과 확인 가능
    - 상대적으로 속도가 느림
    - 간단한 프로그램, 모델 서빙 등에 적합

### **6. 파이썬의 REPL 과정**

- Read: 코드 읽기
- Evaluate: 코드 실행(기계어로 번역)
- Print: 결과 출력
- Loop: 반복

# **사례/예시**

- 샌드위치 만들기 코딩 사례: 아버지(컴퓨터)에게 샌드위치 만드는 방법을 설명하는 아이들의 예시를 통해 프로그래밍의 어려움 설명
- 순서도 예시: "빵 위에 딸기잼을 바르는" 과정을 순서도로 표현하여 알고리즘적 사고 설명

# **강조사항**

- 컴퓨터는 우리가 지시한 대로만 정확히 동작하므로, 명확하고 단계적인 지시가 필요함
- 프로그래밍에서는 순서(알고리즘)와 데이터 처리 방식(자료 구조)이 중요
- 처음에는 순서도를 그려서 문제 해결 방식을 시각화하는 것이 도움이 됨
- 파이썬은 인터프리터 언어로, 한 줄씩 실행하여 결과를 즉시 확인할 수 있음

# **실습/과제 정보**

- Google Colab 사용법:
    - 파일을 복사하여 자신의 Google Drive에 저장
    - 코드셀 사용 방법 (코드셀 생성, 실행)
    - 주요 단축키:
        - Ctrl+Enter: 코드셀 실행 후 같은 셀에 머무름
        - Shift+Enter: 코드셀 실행 후 다음 셀로 이동
        - Alt+Enter: 코드셀 실행 후 새로운 셀 생성
        - Ctrl+M A: 현재 셀 위에 새로운 셀 삽입
        - Ctrl+M B: 현재 셀 아래에 새로운 셀 삽입
- 파이썬 파일 종류:
    - .py: 전체 코드를 한 번에 실행
    - .ipynb: 코드를 셀 단위로 나누어 실행 가능한 주피터 노트북 형식

### **1. 코랩(Colab) 환경 이해하기**

- **코랩 연결 상태**: 코랩은 미사용 시 36시간 후 자동으로 연결 해제됨
- **리소스 할당**:
    - 기본: RAM 12GB, 디스크 100GB
    - GPU 옵션: T4 GPU(무료), L4/A100/H100 GPU(유료)
- **런타임 타입**: 'Runtime Type' 메뉴에서 CPU/GPU 선택 가능

### **2. 코랩 셀 사용법**

- **코드 셀**: 파이썬 코드를 실행할 수 있는 셀
- **텍스트 셀(마크다운)**: 문서화를 위한 셀
- **셀 생성/이동**:
    - 새 셀 생성: `+ 버튼` 또는 `Ctrl+M B`(아래에 생성), `Ctrl+M A`(위에 생성)
    - 셀 실행: `Shift+Enter` 또는 `Ctrl+Enter`
- **셀 변환**:
    - 코드 셀 → 텍스트 셀: `Ctrl+M M`
    - 텍스트 셀 → 코드 셀: `Ctrl+M Y`

### **3. 마크다운 사용법**

- **텍스트 서식**:
    - 제목: `#`, `##`, `###` 등
    - 강조: `*텍스트**`
    - 이탤릭체: `텍스트*`
- **목차**: 마크다운으로 작성한 제목은 자동으로 목차에 추가됨

### **4. 파이썬 코드 작성 규칙(PEP 가이드)**

- **들여쓰기**: 4칸 들여쓰기 권장
- **코드 줄 길이**: 한 줄에 79자 초과하지 않도록 권장
- **줄바꿈**: 코드 줄이 길어질 경우 `\\`(백슬래시)를 사용해 줄바꿈 가능
- **연산자 위치**: 복잡한 연산식에서는 연산자 이전에 줄바꿈 권장
- **함수/클래스 구분**: 함수나 클래스 선언 앞뒤로 두 줄 띄우기 권장
- **문단 구분**: 논리적 구분을 위해 적절한 공백 사용 권장

### **5. 셀 명령어(Cell Commands)**

- **셸 명령어(`!`)**: 코랩 환경의 터미널에 명령 전달
    - 예: `!python --version`, `!pip install numpy`
- **매직 명령어(`%`)**: 주피터 노트북 환경에서 특별한 기능 수행
    - `%time`: 한 줄의 실행 시간 측정
    - `%%time`: 셀 전체의 실행 시간 측정
    - `%%writefile`: 파일 작성

### **6. 변수와 메모리 관리**

- **변수 정의**: 메모리 주소에 이름을 붙인 것
- **메모리 구조**:
    - 주기억장치(RAM): 휘발성, CPU가 직접 접근 가능
    - 보조기억장치(HDD/SSD): 비휘발성, 파일 저장
- **메모리 주소**: `id()` 함수로 확인 가능
- **자주 사용하는 값**: 작은 정수, True/False 등은 미리 메모리에 로드됨
- **변수 삭제**: `del` 명령어 사용

### **7. 파이썬 문자열 다루기**

- **따옴표 사용**: 작은따옴표(`'`)와 큰따옴표(`"`)는 동일한 기능
- **이스케이프 문자**: 백슬래시(`\\`)로 특수문자 표현
- **여러 줄 문자열**: 큰따옴표 세 개(`"""`) 또는 작은따옴표 세 개(`'''`)로 표현

# **강조사항**

- 코랩은 일정 시간 미사용 시 자동으로 연결이 해제되므로 중요한 작업은 저장 필요
- 코드셀과 텍스트셀을 적절히 활용하여 코드와 설명을 함께 정리하는 것이 효과적
- PEP 가이드는 가독성을 위한 권장사항으로, 코드가 실행되기만 하면 반드시 따를 필요는 없음
- 코랩에서는 마지막 실행 결과가 메모리에 남아 표시되는 특성이 있음(REPL 원리)
- 변수명이 파이썬 내장 함수와 같은 이름을 사용할 경우 내장 함수를 덮어쓰게 되므로 주의 필요

# **실습/예시**

1. **코드셀과 텍스트셀 전환**: 설명과 코드를 적절히 구분하여 작성하기
    
2. **문자열 출력방법 비교**:또는
    
    python복사
    
    `print("Hello World")print("Batch Edutech")print("Batch Edutech")`
    
    python복사
    
    `"""Hello WorldBatch EdutechBatch Edutech"""`
    
3. **셸 명령어 사용**: `!python --version`, `!pip install package_name`
    
4. **실행 시간 측정**: `%time print("Hello")` 또는 `%%time` + 여러 줄 코드
    

### **1. 파이썬 변수 명명 규칙**

- **예약어 사용**: 파이썬의 내장 함수나 키워드(예: `list`)를 변수명으로 사용하면 원래 기능이 덮어씌워짐
    - 필요시 변수명 뒤에 언더바를 붙여 회피 가능 (예: `list_`)
    - `del` 명령어로 변수 삭제하면 원래 기능 복구 가능
- **언더바 사용 관례**:
    - 변수명 앞에 언더바(`_`) 사용: 외부에서 접근하지 않았으면 하는 변수/함수
    - 변수명 앞뒤 이중 언더바(`__name__`): 파이썬 내부적으로 사용하는 특수 변수/함수
- **케이스 스타일**:
    - 파이썬 권장: 스네이크 케이스(snake_case) - 소문자와 언더바 사용
    - 클래스명: 파스칼 케이스(PascalCase) - 대문자로 시작
    - 다른 스타일: 카멜 케이스(camelCase), 케밥 케이스(kebab-case), 파스칼 케이스(PascalCase)
- **변수명 제한**:
    - 숫자로 시작 불가능 (예: `1apple` 불가, `apple1` 가능)
    - 특수문자는 일부(`_`) 제외하고 사용 불가
    - 한글 변수명도 가능하지만 권장하지 않음 (인코딩 문제 발생 가능)

### **2. 파이썬의 네임스페이스(Namespace)**

- 변수명과 메모리 주소를 연결해주는 중간 단계
- 변수명이 직접 메모리를 가리키지 않고 네임스페이스를 통해 매핑됨
- 장점:
    - 효율적인 메모리 관리 (불필요한 임시 변수 생성 없이 값 교환 가능)
    - 함수도 변수처럼 취급 가능
- 예시: `a, b = b, a` - 파이썬에서 변수값 교환이 간단한 이유

### **3. 기본 자료형 (기본형/스칼라 타입)**

1. **정수(int)**
    - 음수, 0, 양수 모두 포함
    - 파이썬은 크기 제한 없이 큰 정수 처리 가능
    - 기본 4바이트 할당 + 메타데이터 오버헤드 발생
    - 천 단위 구분 시 언더바 사용 가능 (예: `1_000_000`)
2. **실수(float)**
    - 부동소수점 방식으로 저장
    - 특징: 소수점 위치가 가변적, 표현 범위가 넓지만 정확도에 제한
    - 부동소수점 오차 발생 가능 (예: `0.1 + 0.2 = 0.30000000000000004`)
    - 정밀한 계산 필요시 `decimal` 모듈 사용 가능
    - 과학적 표기법 지원: `1e3` (1000), `1e-3` (0.001)
3. **불리언(bool)**
    - `True`와 `False` 값 (파이썬에서는 대문자로 시작)
    - 내부적으로 `True`는 1, `False`는 0으로 처리
    - 산술 연산 가능: `True + True = 2`, `True + False = 1`
    - 조건문과 반복문에서 활용
4. **문자열(str)**
    - 작은따옴표(`'`), 큰따옴표(`"`), 삼중따옴표(`'''` 또는 `"""`) 사용 가능
    - 이스케이핑 문자: 백슬래시(`\\`)로 특수문자 표현
        - `\\'`, `\\"`, `\\n`, `\\t` 등
    - Raw 문자열: `r"C:\\Users\\name"` - 이스케이핑 처리 무시
    - 빈 문자열(`""`)과 공백 문자열(`" "`)은 서로 다름
    - 대소문자 구분
5. **None 타입**
    - 값 없음을 의미하는 특별한 타입
    - 변수 선언만 하고 초기화는 나중에 할 때 사용
    - 연산 불가능 (예: `None + None` → TypeError)

### **4. 기본 연산자**

- **산술 연산자**:
    - 덧셈(`+`), 뺄셈(), 곱셈(), 나눗셈(`/`)
    - 제곱(`*`): `2**3` = 8
    - 몫(`//`): `7//3` = 2
    - 나머지(`%`): `7%3` = 1
- **연산 특성**:
    - 나눗셈(`/`)은 항상 float 타입 결과 반환
    - 서로 다른 타입끼리 연산 시 자동 형변환 (단, 문자열과 숫자는 불가)

# **사례/예시**

1. **변수 값 교환**:
    
    python복사
    
    `# 방법 1: 임시 변수 사용a = 10b = 20tmp = aa = bb = tmpprint(a, b) # 20 10
    
    # 방법 2: 파이썬 튜플 언패킹 활용a = 10b = 20a, b = b, aprint(a, b) # 20 10`
    
2. **부동소수점 오차와 decimal 모듈 사용**:
    
    python복사
    
    `# 부동소수점 오차 예시0.1 + 0.2 # 0.30000000000000004
    
    # decimal 모듈 사용from decimal import DecimalDecimal('0.1') + Decimal('0.2') # Decimal('0.3')`