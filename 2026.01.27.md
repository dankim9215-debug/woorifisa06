1.데이터베이스 설계

1-1.데이터베이스 스키마

- 테이블은 데이터베이스의 기본 구성 요소임
    
- 테이블을 설계할 때, 정확성과 무결성을 유지하면서 효율성을 고려해야 함
    
- 테이블 간의 관계를 설정하여, 특정 테이블의 값을 다른 테이블에 반영하거나 그 반대를 가능하게 함
    
- 제약 조건을 통해, 특정 테이블과 테이블 사이의 관계를 효과적으로 관리할 수 있음
    
- 테이블의 제약 조건은 테이블 단위에서만 설정할 수 있음
    

1-2.제약 조건

- 데이터베이스는 여러 개의 테이블을 중복으로 관리하며, 제약 조건을 통해 테이블 간의 관계를 설정함
    
- 테이블 단위의 제약 조건은 데이터베이스 스키마를 통해 관리됨
    
- 예를 들어, 'ERP의 직원번호' 테이블과 'DPP와' 컬럼을 통해, 직원의 번호와 DPP 사용 여부를 결정할 수 있음
    
- 데이터베이스 스키마에서 제약 조건을 설정할 때, 해당 테이블은 '프로그램이랑' 테이블에 반영되어 사용됨
    
- 테이블의 제약 조건은 컬럼 단위의 제약 조건과 마찬가지로 데이터베이스 스키마를 통해 관리됨
    

1-3.테이블과 데이터 관계

- 테이블은 컬럼의 데이터를 관리하며, 컬럼은 데이터의 유일한 값이나 여러 값을 가질 수 있는 공간임
    
- 데이터베이스는 테이블을 통해 다양한 데이터를 연결하고, 각각의 테이블은 중복을 통해 관리됨
    
- 테이블 간의 관계를 설정하여, 없는 사람의 정보를 참조하거나 한 사람의 정보를 다른 사람에게 전달하는 등 효율적으로 데이터를 활용할 수 있음
    
- 테이블을 설계할 때, 제약 조건을 통해 테이블의 사용을 효과적으로 관리할 수 있음
    
- 예를 들어, '쇼핑몰의 고객' 테이블은 고객의 번호와 구매 여부를 기준으로 분류되어 관리됨
    

2.DCT를 이용한 DTS 제약 조건

2-1.DCT와 DSS의 기능

- DCT에서 에러를 해소하기 위해 DSS를 사용함
    
- DSS는 디앱 컬럼을 관리하고, 이는 DPPMO에 의해 실행됨
    
- DPPMO의 값들에 대해 허용하며, 테이블과 테이블 사이의 제약 조건을 볼 때 총 3가지 옵션을 제공함
    
- 제약 조건을 테이블 사이에 걸어주는 명령어를 사용함
    
- 제약 조건을 적용할 때, 외래키를 걸어주며, 이는 레퍼런스를 참조함
    

2-2.제약 조건에 대한 이해

- 제약 조건은 외래키를 참조하며, 이를 통해 외래의 실제 데이터를 보호함
    
- 꼬리는 외래키를 참조하여 유투스 여유를 관리함
    
- 제약 조건을 통해 데이터의 변조를 방지하며, 외래키의 참조는 동료 테이블에서 발생함
    
- DCT를 이용해 제약 조건을 생성하고, 이를 DSS에서 사용함
    

2-3.제약 조건에 대한 실제 적용

- 제약 조건을 생성하고, 이를 DSS에서 확인함
    
- 실제 테이블에서의 제약 조건 적용을 통해 테이블의 변조를 방지함
    
- 테이블에 대한 제약 조건을 명령어로 작성하며, 이를 통해 테이블 내부의 외래키를 참조함
    
- 제약 조건을 통해 데이터의 변조를 방지하고, 테이블의 변조를 모니터링함
    
- 제약 조건을 통해 테이블의 특정 항목들 사이의 관계를 명확하게 설정함
    

3.테이블 정렬과 제약

3-1.테이블 정렬과 기본 개념

- 데이터베이스에 테이블을 생성하고 수정할 때, 정렬과 제약을 통해 데이터를 미리 정렬하고 삽입함
    
- 테이블에 정렬을 하고 제약을 넣어 데이터의 순서와 범위를 명확히 함
    
- 데이터를 삽입할 때, 미리 정렬된 데이터를 사용하여 테이블의 순서와 범위를 유지함
    
- 테이블에 삽입할 때는 제약 조건을 통해 데이터의 순서와 범위를 명확히 함
    
- 데이터의 순서와 범위를 명확히 하기 위해 테이블에 '프라이머리'라는 이름을 지정하고, '필수 조건'을 넣어 정렬함
    

3-2.제약 조건의 이해

- 제약 조건은 테이블의 특정한 셀에 대한 조건을 의미함
    
- 제약 조건을 통해 데이터의 순서와 범위를 보장하고, 다른 데이터의 조건을 확인할 수 있음
    
- 예를 들어, ' Employees' 테이블에 '직위'라는 제약 조건을 넣어 '사원' 테이블의 '직위'를 확인할 수 있음
    
- 제약 조건은 테이블에 '프라이머리'라는 이름을 지정하고, '필수 조건'을 넣어 정렬하게 함
    
- 제약 조건을 통해 데이터의 순서와 범위를 명확히 하고, 다른 데이터의 조건을 확인할 수 있음
    

3-3.제약 조건의 예시

- '부서' 테이블에 '직위'라는 제약 조건을 넣어 '사원' 테이블의 '직위'를 확인할 수 있음
    
- 제약 조건을 통해 '사원' 테이블의 '직위'가 '사원' 테이블의 '직위'보다 높은 것만 허용하도록 함
    
- 이처럼, 제약 조건을 통해 데이터의 순서와 범위를 명확히 하고, 다른 데이터의 조건을 확인할 수 있음
    
- 제약 조건을 넣어 '사원' 테이블의 '직위'를 '사원' 테이블의 '직위'보다 높은 것만 허용하도록 함
    
- 이렇게 제약 조건을 활용하여 데이터의 순서와 범위를 보장하고, 다른 데이터의 조건을 확인할 수 있음
    

4.데이터 관리의 원칙과 실천

4-1.데이터 관리의 원칙과 엄격한 원칙

- 데이터 저장의 원칙은 문제가 생기면 문제를 해결하려고 하지 않고, 데이터를 보존하는 것
    
- 특히 완벽한 보존을 위해 엄격한 원칙을 설정하고, 현실에서 이를 실현하기는 어려움
    
- 관계를 엄격하게 설정하여 데이터의 정확성을 유지
    
- 하지만 이 원칙은 현실적으로 어려워서 일부만 적용되거나 관리자에 따라 다르게 적용될 수 있음
    

4-2.상세 사례와 데이터 관리의 실천

- 회원 탈퇴 시, 아직 배송되지 않은 상품이 남아있다면 탈퇴를 거부할 수 있는 옵션 제공
    
- 테이블 간의 관계를 변경하는 과정에서 원칙을 따르되, 현실적으로 필요에 따라 유연하게 적용
    
- 부모 테이블의 부서 정보를 변경하려 할 때, 부모 테이블과의 관계를 고려하여 옵션 변경 필요
    
- 단순히 값을 변경하는 것이 아니라, 해당 옵션을 통해 테이블 간의 연결을 유지하려는 노력
    

4-3.실제 데이터 관리의 예시와 해결방안

- 실제 데이터베이스에서 이런 방식으로 관리하면, 데이터 삭제에 대한 메시지를 줄일 수 있음
    
- 테이블 간의 관계를 변경할 때, 처음에는 복잡해보일 수 있지만, 테이블 간의 연결을 유지하려는 노력이 중요
    
- 테이블의 값을 변경하려 할 때, 테이블 간의 연결 상태를 고려하여 변경하는 것이 필요
    
- 디렉션을 통해 원칙을 따르면서도 현실에 맞게 데이터 관리를 진행할 수 있음
    

5.데이터베이스 테이블 활용과 관리

5-1.데이터베이스 테이블의 활용

- 데이터베이스에서 사용하는 테이블은 '샘널'이라는 이름을 사용
    
- 샘널의 사용법은 '모두를 무시하고 해당 테이블에 맞춰서 데이터를 처리''
    
- 샘널을 이용하면 테이블이 '시장 한쪽 칼럼을 멀리 처리'함
    
- 샘널의 기능을 활용하면 원하는 데이터의 변경사항을 '직원의 권한'을 통해 처리 가능
    
- 테이블은 슬프로써 변경할 수 없으며, '부모 테이블에 없는 것들을 사용할 수 없음' 확인
    

5-2.테이블 간의 관계 확인

- 데이터베이스에서 테이블 간의 관계를 확인하는 '인포메이션 스키마' 사용
    
- 인포메이션 스키마는 '스키마들의 정보를 일괄적으로 표시'함
    
- 테이블 간 제약 조건 확인 시 '인포메이션 스키마'를 활용
    
- 인포메이션 스키마는 테이블 간의 관계를 확인해주는 수단으로 활용
    

5-3.데이터베이스 테이블의 효율적 관리

- 테이블 관리 시 '팬덤'을 활용해 효과적으로 데이터를 관리
    
- 테이블 안의 데이터가 다른 카테고리에 들어있을 때, 팬덤을 활용해 관리
    
- 데이터를 넓게 분류하면, 검색 결과도 넓게 나타나게 됨
    
- 데이터베이스 테이블의 효율적 관리를 위해 '팬덤' 활용 권장
    

6.테이블 제약

6-1.테이블 제약 조건 이해

- 테이블 제약 조건은 '성질', '제약', '해제'로 나뉨
    
- '성질'은 테이블의 특성, '제약'은 테이블의 값을 제한하는 조건, '해제'는 테이블의 변경을 제한하는 조건임
    
- 테이블의 성질과 제약은 '직접 조건'으로, 제약은 '간접 조건'으로 표현함
    
- '성질'과 '제약'은 테이블의 '개별 속성'과 '값'에 영향을 미침
    
- '제약'은 테이블의 '변수'에 접근을 제한하거나 특정 조건을 주어질 때 사용함
    

6-2.제약 조건의 사용

- '프라이머리 키'는 테이블의 '키'를 가리킴
    
- '키'를 포함한 '주제 키'는 테이블의 '개별 속성'을 가리키며, 이는 '키'에 '직접 조건'을, '주제 키'에 '간접 조건'을 빌려서 사용함
    
- '추가 키'는 테이블의 '추가 속성'을 가리키며, '추가 키'에 '직접 조건'을 빌려서 사용함
    
- '변조 키'는 테이블의 '변조 속성'을 가리키며, '변조 키'에 '직접 조건'을 빌려서 사용함
    
- '서브 키'는 '추가 키'에 '서브 키'를 가리키며, '서브 키'에 '직접 조건'을 빌려서 사용함
    

6-3.제약 조건의 활용

- '프라이머리 키'는 테이블의 '키'를 가리키며, '키'에 '직접 조건'을 빌려서 사용함
    
- '추가 키'는 테이블의 '추가 속성'을 가리키며, '추가 키'에 '직접 조건'을 빌려서 사용함
    
- '변조 키'는 테이블의 '변조 속성'을 가리키며, '변조 키'에 '직접 조건'을 빌려서 사용함
    
- '서브 키'는 '추가 키'에 '서브 키'를 가리키며, '서브 키'에 '직접 조건'을 빌려서 사용함
    
- 제약 조건은 '직접 조건'을 이용해 '키' 또는 '서브 키'에 접근을 제한하거나 특정 조건을 주어질 때 사용함
    

7.테이블 유니크

7-1.유니크 키와 계약 조건

- 테이블 스키마 생성 시, 유니크 키와 계약 조건을 활용하여 데이터의 유일성과 순서를 보장함
    
- 유니크 키는 고유값을 동원하여 제작하며, 내부적으로 별도로 생성하지 않아도 됨
    
- 계약 조건은 순서대로 값이 들어가는 키를 생성함
    
- 프라이머리 키는 중복을 방지하고, 엔고딩 동조를 확인하는 데 사용됨
    
- 프라이머리 키에 엔코딩 동조를 확인하는 조건을 삽입하여, 새로운 값이 저장되지 않도록 함
    

7-2.유니크 키와 프라이머리 키의 차이

- 프라이머리 키는 고유값을 기반으로 하며, 다른 컬럼에 고유값을 적용하더라도 유일성을 보장함
    
- 프라이머리 키를 사용하여 엔코딩 동조를 확인할 수 있음
    
- 유니크 키와 프라이머리 키는 테이블 스키마 생성 시 자동으로 생성되며, 수동으로 생성할 수 없음
    
- 유니크 키와 프라이머리 키 모두 테이블 내에서 순서대로 값을 저장함
    
- 테이블 내에서 같은 키가 존재할 경우, 해당 키가 유일한 것과 동일함
    

7-3.테이블 스키마의 유니크 조건과 맵핑

- 유니크 조건은 복제를 할 수 없으며, 키 자리에 있으면서 값이 순서대로 저장되는 키를 생성함
    
- 테이블 간의 맵핑을 확인할 때, 키가 있을 경우 테이블 간 관계를 맺음
    
- 명령어로 테이블을 생성하거나, 테이블을 보여주고 값을 입력할 수 있음
    
- 테이블을 생성할 때, 의도한 대로 값을 입력하기 어려우므로, 필요한 키를 별도로 생성하여 테이블에 저장하는 것이 일반적임
    
- 명령어로 테이블을 생성할 때, '과다분해', '부분해', '보여주기' 명령어를 사용할 수 있음
    

8.데이터 엑스포트

8-1.데이터 관리

- 서버에 데이터 엑스포트를 확인해 테이블만 가져와서 활용함
    
- 로퍼스트에서 작업한 후 합칠 때, 테이블을 데이터 엑스포트에서 가져와서 활용함
    
- 서버에 데이터 엑스포트를 스페이스 페이스로 넣어 빠르게 진행함
    
- '에큐얼 파일'이 있을 때, '에큐얼 파일'로 데이터를 가져와 활용함
    
- 테이블 간의 관계를 정의하는 'DMPM'을 이용하면 편리함
    

8-2.제약 조건

- 테이블 간의 계약 조건을 명시하면 테이블 간의 관계를 알 수 있음
    
- 계약 조건을 통해 테이블을 드랍하거나 사용하지 않는 방법으로 제약 조건을 설정할 수 있음
    
- 계약 조건을 직접 확인할 때는 까다롭지만, '디바이스 드랍'을 하는 편리한 방법도 있음
    
- 테이블 간 관계를 떠올리거나, 'ttable'로 테이블을 확인하는 방법도 있음
    
- 명시된 계약 조건을 테이블에 적용하고, '에러'를 확인하면 확인 방법에 오류가 있음을 알 수 있음
    

8-3.데이터 엑스포트

- 데이터 엑스포트를 통해 테이블을 가져오거나, 새로운 테이블을 생성할 수 있음
    
- 'DMPM'에서 테이블을 확인하거나, 직접 테이블을 확인할 수 있음
    
- 제약 조건을 설정하면, 해당 조건에 따라 테이블을 드랍하거나 사용하지 않는 방법으로 제약 조건을 설정할 수 있음
    
- '에러'를 확인하면 제약 조건에 오류가 있음을 알 수 있음
    
- 제약 조건을 명시하면 테이블 간의 관계를 알 수 있고, 드랍하거나 사용하지 않는 방법으로 제약 조건을 설정할 수 있음
    

9.테이블 제약 조건

9-1.테이블 제약 조건 이해

- '에프모리 키' 조건을 추가하여 테이블에 '프라이버시키' 조건을 설정할 수 있음
    
- 고유값으로 관리하는 경우, '프라이버시키' 조건을 통해 중복을 허용하지 않으면서도 중복을 허용하는 것을 조절할 수 있음
    
- 중복을 허용하는 조건을 확인하는 것이 중요함
    
- 중복을 허용하는 조건은 중복 허용 여부를 포함하여 테이블에 저장되어야 함
    
- 중복 허용 조건을 변경한 후, '에프모리 키' 조건을 다시 추가하여 테이블을 업데이트해야 함
    

9-2.테이블 제약 조건 예시

- '에프모리 키' 조건을 추가하여 중복을 허용하지 않으면서도 테이블을 업데이트할 수 있음
    
- '에프모리 키'에 '프라이버시키' 조건을 추가하여 중복을 허용하지 않으면서도 중복을 허용하는 것을 확인할 수 있음
    
- 중복을 허용하는 조건을 확인하고, '에프모리 키' 조건에 '프라이버시키'를 추가하여 중복을 허용하지 않으면서도 테이블을 업데이트할 수 있음
    
- 테이블을 업데이트할 때, '에프모리 키' 조건에 따라 중복을 허용하는 것을 확인해야 함
    
- '에프모리 키'에 '프라이버시키' 조건을 추가하여 중복을 허용하지 않으면서도 테이블을 업데이트해야 함
    

9-3.테이블 제약 조건 추가

- '에프모리 키' 조건에 '프라이버시키'를 추가하여 중복을 허용하지 않으면서도 테이블을 업데이트할 수 있음
    
- '에프모리 키'에 '프라이버시키' 조건을 추가하여 중복을 허용하지 않으면서도 테이블을 업데이트할 수 있음
    
- 테이블을 업데이트할 때, '에프모리 키' 조건에 따라 중복을 허용하는 것을 확인해야 함
    
- '에프모리 키'에 '프라이버시키' 조건을 추가하여 중복을 허용하지 않으면서도 테이블을 업데이트해야 함
    
- 테이블 업데이트 시, '에프모리 키' 조건에 따라 중복을 허용하는 것을 확인해야 함
    

10.DDL 관계

10-1.테이블 복제 시 유의점

- 테이블 구조 복제 시 프라이머리 키는 관리함
    
- 대신 컬럼 간 관계를 조건으로 정해 정확성 유지함
    
- 복제 후 문제 발생 시 오류를 확인함
    
- 레퍼런스 테이블을 통한 빌리드 오프를 주의함
    
- 구조 복제 후 수정과 삭제 시 레퍼런스 업데이트 반영됨
    

10-2.테이블 구성 요소 정리

- 테이블에 데이터를 삽입할 때, 키를 참조하는 요소를 정의함
    
- 부모 테이블은 잘 바뀌지 않는 값, 자주 변경되지 않는 요소를 저장함
    
- 자주 변경되는 요소는 부모 테이블에 저장하고, '그리기'는 참조를 통해 사용함
    
- '불리우기'는 부모 테이블의 참조를 통해 자주 변경되는 요소를 의미함
    
- 부서 관리 테이블에 '직접 작성'을 통해 참조하도록 설정함
    

10-3.부서 관리 테이블 작성

- '직접 작성'을 통해 부서 관리 테이블을 작성함
    
- 테이블에 '직접 주어진 값'을 삽입하고, '직접 빌리드 오프'를 통해 참조를 통해 사용함
    
- 부서 관리 테이블에 '직접 테이블 삽입' 조건을 추가하여, '직접 부서 관리 테이블'을 생성함
    
- '직접 테이블 삽입' 조건은 '직접 빌리드 오프'를 통해 부서 관리 테이블에 삽입됨
    
- 테이블에 '직접 주어진 값'을 삽입할 때, '직접 테이블 삽입' 조건을 활용함
    

11.DPT 테이블 조건

11-1.DPT 테이블 기본 조건

- DPT 테이블에 값을 삽입하거나 수정할 때, 임시 테이블을 생성해 메모리 암호수를 관리함
    
- 임시 테이블에서 '연결된 테이블'을 선택해 '노액션'을 적용해 조건 삽입
    
- '노액션'은 '이 조건이 변경되면 새로운 테이블을 생성해 저장한다'는 의미
    
- 본사 조건을 남겨두고, '20번 부서'만 선택해 값 삽입
    
- 'DPT 모드'로 명령하고, 'DPT 검사' 조건에 '에러 메시지'가 나옴
    

11-2.조건 삽입 방법

- '테이블에 제약 조건을 추가하거나 변경한다'고 명령
    
- '노액션'을 적용해 조건 삽입, '이 조건은 변경되면 새로운 테이블을 생성한다'고 명령
    
- '로액션'은 순서만 기억해 두는 것이므로 '피신'과 '모드'를 시키면 됨
    
- 'DPT에 DPTM을 200으로 변경한다'고 명령
    
- '다른 테이블에 '제약 조건을 추가한다'고 명령
    

11-3.조건 수정 방법

- '테이블에 제약 조건을 추가하거나 변경한다'고 명령
    
- '노액션'을 적용해 조건 수정, '이 조건은 변경되면 새로운 테이블을 생성한다'고 명령
    
- '부모 테이블에 있는 DPT를 선택한다'고 명령
    
- '에러 메시지'가 나옴
    
- '제약 조건에 위배되는 값이 있으면 조건을 변경한다'고 명령
    

12.테이블 제약 조건

12-1.제약 조건 생성

- '에러 메시지'로 값 제약 조건을 확인할 수 있음
    
- '에러 메시지'에서 '값이 없으면 0으로 허용'을 확인할 수 있음
    
- '에러 메시지'로 '무조건 0으로 허용'을 확인할 수 있음
    
- 값이 있으면 그대로 유지, 없으면 기본값을 넣어 제약 조건 생성
    
- 제약 조건은 하나의 조건만으로 여러 개 존재 가능
    

12-2.제약 조건 변경

- '에러 메시지'로 제약 조건 변경 가능
    
- 0보다 큰 값만 넣으려 했으나 0이 아닌 다른 값 넣어 제약 조건 변경
    
- '에러 메시지'로 '0보다 크거나 같고, 100보다 작거나 같고, 120보다 크다' 확인
    
- '에러 메시지'로 '0보다 크거나 같고, 100보다 작거나 같고, 120보다 크다' 확인
    
- 여러 개의 제약 조건을 확인 가능
    

12-3.제약 조건 삭제

- '에러 메시지'로 '무조건 0으로 허용' 제약 조건을 삭제
    
- '에러 메시지'로 '무조건 0이 아닌 값으로 허용' 제약 조건 확인
    
- '무조건 0이 아닌 값으로 허용' 제약 조건 생성
    
- '에러 메시지'로 '무조건 0이 아닌 값으로 허용'을 확인
    

13.데이터베이스 테이블 삽입과 조회

13-1.테이블 삽입과 기본

- 테이블 삽입 시, '올바른' 테이블을 선택하는 것이 중요함
    
- 데이터베이스의 기존 테이블을 참조하는 방법을 알아야 함
    
- 기본 테이블이 '보통'과 '숫자' 자료형일 경우, '0'을 넣어주어야 함
    
- 테이블에 넣을 때, '올바른' 테이블을 선택하는 것이 중요함
    
- 참조하는 테이블이 '보통'과 '숫자' 자료형일 경우, '0'을 넣어주어야 함
    

13-2.테이블 외 객체 관리

- 테이블 외에 테이블을 효과적으로 사용하기 위한 객체들이 있음
    
- '인덱스', '색인', '트리거 함수', '컬러드 프로시저', '리스트' 등이 있음
    
- 데이터가 많아지면 조회가 힘들기 때문에, 인덱스를 사용해 빠르게 조회할 수 있음
    
- 인덱스를 사용하면 조회 시간이 줄어들지만, 값 수정, 삽입, 삭제 시 인덱스 재계산이 필요함
    
- 조회 시간을 줄이려면, '리스 노드부터 브랜치 노드까지'하며 조회함
    

13-3.조회의 효율성과 한계

- 조회는 B-트와 균형 트리 알고리즘을 사용해 효율적으로 진행됨
    
- 조회 시간은 거의 들지 않고, 많은 양의 데이터를 조회할 수 있음
    
- '보통'과 '숫자' 자료형일 경우, '0'을 넣어줘야 함
    
- 테이블 삽입 시, 데이터 수정과 조회는 거의 들지 않고, 값 삽입과 수정은 거의 들지 않음
    
- 조회를 많이 해야 하는 경우에는, '보통'과 '숫자' 자료형으로 테이블을 선택해야 함
    

14.데이터베이스 인덱스와 그 기능

14-1.데이터베이스 인덱스의 개념과 종류

- 인덱스는 데이터의 물리적 순서를 부여하는 도구임
    
- 클러스터 인덱스, 보조 인덱스, 구조 인덱스 등 다양한 인덱스 종류가 있음
    
- 클러스터 인덱스는 데이터의 클러스터를 결정하고, 보조 인덱스는 다른 열을 기준으로 생성됨
    
- 구조 인덱스는 메모리에 저장되며, 제약 조건을 통해 검색을 빠르게 함
    

14-2.클러스터 인덱스와 보조 인덱스의 기능

- 클러스터 인덱스는 물리적 순서가 아닌 클러스터를 기준으로 생성됨
    
- 보조 인덱스는 테이블에 추가된 열을 기준으로 생성되며, 클러스터 인덱스에 기생함
    
- 클러스터 인덱스와 보조 인덱스 모두 데이터의 검색을 빠르게 하기 위해 사용됨
    
- 클러스터 인덱스가 빠르게 검색을 가능하게 하지만, 보조 인덱스는 별도로 저장되어 속도가 느림
    

14-3.구조 인덱스의 장점과 활용

- 구조 인덱스는 메모리에 저장되어 빠른 검색이 가능함
    
- 구조 인덱스를 이용하면, 데이터의 물리적 순서가 아닌 클러스터를 기준으로 검색 가능
    
- 클러스터 인덱스가 변경될 때, 구조 인덱스를 통해 데이터의 위치를 먼저 찾고 데이터를 찾아오는 방식 사용
    
- 단, 구조 인덱스는 추가적인 저장 공간이 필요하므로, 복잡한 데이터를 저장할 때 필요함
    

15.테이블 인덱스

15-1.인덱스의 필요성과 종류

- 데이터의 검색, 삽입, 수정, 삭제 시 인덱스가 필요함
    
- 테이블의 인덱스는 외래키와 구조 인덱스로 나뉨
    
- 인덱스는 테이블에 새로운 레코드를 삽입하거나 수정하거나 삭제할 때 생성됨
    
- 인덱스는 메모리의 용량을 차지하며, 사용하지 않는 인덱스는 메모리 낭비임
    
- 인덱스를 통해 데이터 특성에 따라 원하는 검색이 가능함
    

15-2.인덱스의 활용

- 인덱스를 통해 검색 시 중복된 데이터를 제거할 수 있음
    
- 중복된 데이터가 많은 경우, 인덱스를 통해 중복된 값을 찾으면 오히려 성능에 나쁜 영향을 미침
    
- 외래키를 사용해 데이터의 검색을 빠르게 하는 방법도 있음
    
- 드랍 시 인덱스를 걸어두면 새로운 데이터를 생성하며, 중복된 값이 자동으로 걸러지도록 설정할 수 있음
    
- 이미 만들어진 인덱스에 부여를 통해 중복된 데이터를 제거할 수 있음
    

15-3.인덱스의 부작용과 대응

- 인덱스를 통해 테이블의 검색과 삽입, 수정, 삭제가 빠르게 이루어질 수 있음
    
- 그러나 데이터 변경이 자주 이루어지면 인덱스 변경도 동일하게 발생하므로 주의해야 함
    
- 중복된 값이 있는 컬럼에 인덱스를 부여하면, 해당 컬럼의 모든 값에 인덱스가 걸려있도록 설정됨
    
- 부여된 인덱스는 원본 테이블에 영향을 주지 않음
    
- 인덱스를 통해 중복된 데이터를 제거하면, 원본 테이블의 데이터에는 변화가 없음
    

16.데이터베이스와 인덱스 이해

16-1.데이터베이스와 인덱스의 기본 이해

- 데이터베이스계에서 인덱스에 대한 설명과 중요성을 강조함
    
- DB와 리얼 마이에스 책을 통한 인덱스에 대한 심층적 이해를 권장함
    
- SQL DB를 기반으로 테이블 생성과 인덱스 작성을 실습함
    
- 사용자 아이디를 문자열로 설정하고, 프라이머리 키를 생성하는 과정을 소개함
    

16-2.인덱스의 특징과 활용

- 인덱스의 주요 키에 대해 자세히 설명하고, 이를 통해 테이블의 유니크와 주소를 구현함
    
- 인덱스의 특징인 허용하지 않는 중복, 테이블의 순서, 프라이머리 키 생성 방식 등을 소개함
    
- 인덱스의 활용 예시를 통해 그 사용의 필요성과 중요성을 강조함
    

16-3.인덱스의 관리와 조정

- 테이블 내 인덱스의 관리와 조정에 대해 설명함
    
- 유니크와 널 허용에 따른 인덱스의 변화를 상세히 이해함
    
- 인덱스 설정의 옵션과 주요 특징을 상세히 분석함
    
- 사용자의 편의성을 위해 인덱스 설정을 조정하고 관리하는 방법을 제시함
    

17.클러스터 테이블

17-1.클러스터 테이블 구조

- 클러스터 테이블은 키와 클러스터 인덱스를 가지고 있음
    
- 키는 유저 아이디를 저장하고, 클러스터 인덱스는 순서를 저장함
    
- 순서를 변경할 때 클러스터 인덱스를 수정하면 데이터 재정렬이 일어남
    
- 키가 변경되면, 해당 클러스터 인덱스의 데이터 재정렬이 필요 없음
    
- 키와 클러스터 인덱스가 모두 변경되면, 데이터 재정렬이 필요함
    

17-2.키와 클러스터 인덱스 순서

- 키의 순서는 데이터 삽입이나 수정 시 변경할 수 없음
    
- 클러스터 인덱스는 키의 순서와 동일한 방식으로 정렬됨
    
- 데이터의 재정렬은 키를 먼저 수정한 후, 클러스터 인덱스를 수정하는 방식으로 이루어짐
    
- 클러스터 인덱스 수정 시, 데이터의 재정렬이 필요하지 않음
    
- 데이터 재정렬은 키를 변경한 후, 클러스터 인덱스를 수정하는 방식으로 이루어짐
    

17-3.데이터 삽입과 재정렬

- 데이터 삽입 시, 키를 먼저 수정한 후, 클러스터 인덱스를 수정하면 데이터 재정렬이 필요 없음
    
- 클러스터 인덱스 수정 시, 데이터의 재정렬이 필요함
    
- 키를 수정하지 않고 클러스터 인덱스만 수정할 경우, 데이터 재정렬이 필요 없음
    
- 데이터 수정 시, 데이터의 재정렬이 필요함
    
- 데이터 재정렬은 키 수정과는 별개로 이루어짐
    
1.테이블 인덱스

1-1.인덱스란 무엇인가

- 데이터베이스에서 테이블의 기본 정보를 관리하는 객체임
    
- 기본 키 값에 따라 테이블이 정렬되도록 인덱스를 설정할 수 있음
    
- 인덱스는 고유값을 갖는다의 관계와 유사함
    
- 테이블에서 키를 변경하면 인덱스도 물리적으로 수정되어야 함
    
- 인덱스는 메모리에서 관리되는 객체로, 따로 일할 때 메모리에서 돌리게 됨
    

1-2.인덱스 설정 방법

- 인덱스를 설정하면 테이블 내 개별 값을 삽입하거나 수정할 때 인덱스를 고려해야 함
    
- 인덱스를 통해 테이블 내 값의 순서를 명확히 하고, 조회 시에도 효율적으로 활용할 수 있음
    
- 인덱스는 테이블의 고유값을 기준으로 설정할 수 있음
    
- 인덱스는 테이블에 따라 다르게 설정될 수 있음
    
- 인덱스를 사용하여 데이터의 변경을 줄이고, 효율적인 데이터 검색을 가능하게 함
    

1-3.인덱스 활용 예시

- '선택 사용자 테이블'의 예시에서 인덱스를 사용하여 데이터 검색을 진행함
    
- 이 예시에서 인덱스는 '이름', '이주일', '이일자'로 설정되어 있음
    
- 인덱스는 '이름'과 '이주일'에 대해 고유값을 갖도록 설정되어, '이름'과 '이주일' 중 어느 하나라도 빠지면 다른 값이 해당되어야 함
    
- 이 예시에서 '이 일자'에 대한 인덱스를 설정하면, '이 일자'가 10000 중복으로 간주되어 조회되지 않음
    
- 인덱스를 활용하여 테이블의 검색과 삽입, 수정을 원할하게 할 수 있음
    

2.MSQL의 인덱스

2-1.MSQL 인덱스 생성

- MSQL에서 데이터베이스를 조회할 때, 인덱스를 사용하여 원하는 검색 조건을 추가할 수 있음
    
- 유저 테이블의 네임과 주소를 기준으로 인덱스를 생성하여 검색할 수 있음
    
- 고유값만으로는 검색이 불가능하므로, 보조 인덱스를 추가하여 검색을 용이하게 함
    
- 인덱스를 생성할 때, 검색의 카디널리티를 고려하여 정책에 따라 인덱스를 생성함
    
- 인덱스는 보통 하나의 컬럼에만 값을 넣는 경우를 복합키라고 부름
    

2-2.인덱스 검색

- 인덱스를 이용하여 데이터의 검색 조건을 만들 수 있음
    
- 김범수 씨의 정보를 유저 테이블에 넣어볼 때, 네임과 주소가 중복되어도 인덱스를 통해 검색 가능함
    
- 네임에 프라이머리 인덱스를 걸어두고, 주소의 값이 '1979년, 서울, 미국'일 때도 검색 가능함
    
- 인덱스를 기준으로 데이터의 새로운 속성을 생성하여 검색 조건을 만들 수 있음
    
- 복합키를 사용하여 검색 조건을 만들고, 여러 개의 인덱스를 결합하여 원하는 데이터를 찾을 수 있음
    

2-3.인덱스 활용

- MSQL에서 인덱스를 생성하고 검색할 때, 검색 속도에 따라 다양한 전략을 세워야 함
    
- 고유값이 가장 많은 컬럼을 기준으로 인덱스를 생성하여 검색을 용이하게 할 수 있음
    
- 인덱스를 기준으로 데이터의 새로운 속성을 생성하여 검색 조건을 만들 수도 있음
    
- 복합키를 사용하여 검색 조건을 만들고, 여러 개의 인덱스를 결합하여 원하는 데이터를 찾을 수 있음
    
- 인덱스를 활용하여 데이터의 검색 속도를 높일 수 있음
    

3.테이블 최적화

3-1.복합키 검색

- 복합키로 인덱스를 사용해 검색할 때 복합키를 삽입해 검색하는 방법을 설명함
    
- '네임', '주소', '이름, 날짜' 두 개의 인덱스를 사용해 복합키 '주소'로 검색하는 예시를 들었음
    
- 복합키 삽입 시, 해당 테이블에 대한 인덱스 정보를 보존해 최적화할 수 있음을 강조함
    
- 인덱스를 걸어놓은 결과, 조회된 행이 1개임을 확인할 수 있음을 설명함
    
- 보조 인덱스를 사용해 검색할 때, 클러스터 인덱스를 거쳐 전체 행을 조회하는 방법을 소개함
    

3-2.인덱스 활용

- 보조 인덱스를 사용한 검색 시, 복합키에서 보조 인덱스를 거쳐 최적화된 결과를 반환받을 수 있음을 설명함
    
- 인덱스를 삽입하면 검색의 효율이 개선될 수 있음을 강조함
    
- 복합키를 활용한 검색 시, 인덱스를 삽입한 결과는 빠르게 리턴되어 비효율을 최소화할 수 있음을 설명함
    
- 인덱스를 삽입하지 않은 결과는 클러스터 인덱스를 거쳐 조회되므로, 동일한 정보라도 빠르게 조회할 수 있음을 설명함
    
- 인덱스를 삽입한 결과, 복합키에서 보조 인덱스를 거쳐 전체 행을 조회하는 방식을 다시 한번 강조함
    

3-3.실행 계획

- 복합키로 인덱스를 사용한 검색 시, 실행 계획이 어떻게 달라지는지 설명함
    
- 주소, 이름, 생년월일 인덱스를 사용해 검색하는 예시를 들었음
    
- 실행 계획에서 보조 인덱스를 거쳐 찾는 방법과, 복합키에서 보조 인덱스를 거쳐 찾는 방법을 비교함
    
- 인덱스를 삽입한 결과, 복합키에서 보조 인덱스를 거쳐 조회되는 방식을 다시 한번 강조함
    
- 클러스터 인덱스를 거쳐 조회할 경우, 동일한 정보라도 빠르게 조회할 수 있음을 설명함
    

4.무리스테이블 검색

4-1.테이블 내 조건 활용 검색

- 테이블 내 조건으로 조회 시, 차이 발생 여부 확인 필요함
    
- 프라이버시 키 대신 시퀀스 아이디로 사용해야 충돌 방지 가능함
    
- SQL 쿼리 직접 활용보다 ORM을 활용해 검색하는 것이 편리함
    
- SQL 내부적으로 PK 등장한 값으로 검색하는 것은 예외 발생 가능성 높음
    
- 모비스 TMT 테이블을 예로 들어, 인덱스 설정 시 문제점 설명함
    

4-2.모비스 테이블 인덱스 설정

- 모비스 테이블에 인덱스 설정 필요, 인덱스는 메모리 공간 사용을 의미함
    
- 텍스트 자료형은 인덱스를 설정할 수 없음, 변경 필요함
    
- 디렉터 컬럼에 300자 이내로 변경, '감독 이름 50자'로 제한함
    
- 프라이머리 키를 설정해 검색의 효율성을 높임, 고유값이 아닌 경우 주소로 변경해야 함
    

4-3.검색 조건과 차이 비교

- 검색 시, 차이 발생을 확인하기 위해 조건에 따라 조회함
    
- '고유값이 아니면' 조건에 따라 다른 컬럼으로 조회 시 차이 발생 확인 필요함
    
- 프라이머리 키 대신 다른 컬럼에 인덱스를 걸어두면, 해당 컬럼에 대한 검색이 효율적임
    
- 데이터의 양이 많을 경우, 검색이 느려질 수 있으니 고민 필요함
    
- 데이터 양이 많을 때, 효율적인 검색을 위해 인덱스 설정과 조건 활용이 중요함
    

5.데이터베이스 객체와 뷰 활용법

5-1.데이터베이스 객체 이해

- 데이터베이스에서 검색과 다중 조건 활용 시, 결과의 카디널리티는 저조하게 나타남
    
- 고유값이 큰 디렉터 컬럼에 하나를 걸어주면, 검색 결과는 빠르게 정렬됨
    
- 확인된 결과는 9500명의 고유값을 가지고 있어 확인 가능
    
- 영화 감독 장준환의 작품들을 검색 시, 모든 행을 조회하여 결과를 반환
    
- 이 경우, 작업 계획이 간결하게 나타나 빠른 결과 제공이 가능
    

5-2.클러스터 쓰기와 그 장점

- 클러스터의 주요키를 사용하여 데이터를 효율적으로 검색 가능
    
- 클러스터의 특정 컬럼에 따른 인덱스를 활용하여 데이터를 빠르게 검색
    
- 인덱스는 케이블 단에서 줄이는 것이 아닌, 보조적으로 사용하는 것
    
- 따라서, 인덱스를 통해 많은 양의 데이터를 빠르게 검색 가능
    

5-3.뷰의 활용과 이해

- 뷰는 물리적으로 존재하지 않지만, 바탕화면에 있는 바로가기처럼 물리적으로 메모리에 존재
    
- 긴 서문을 자주 쓰기 싫을 때, 또는 특정 컬럼 값들을 은닉해서 사용해야 할 때 사용
    
- 뷰의 정보는 다른 사람에게 공유를 위한 도구로 사용 가능
    
- 뷰를 이용하여 원하는 행들을 가려주거나, 행의 정보를 숨길 수 있음
    
- 뷰의 이용은 데이터를 효과적으로 관리하고 분석하는 데 도움을 줌
    

6.보안 릴리트

6-1.테이블과 뷰의 차이

- 외부에서 테이블과 뷰를 구분하는 방법을 설명함
    
- 테이블은 뷰와 달리 보안이 강화된 형태라고 강조함
    
- 테이블과 뷰의 차이를 비교하고, 뷰의 보안을 강화하는 방안을 제시함
    
- 보안 강화를 위한 뷰의 참조와 연결고리 개념을 설명함
    
- DDL의 예시를 통해 연결고리 개념을 설명함
    

6-2.원본과 사본의 관계

- 뷰에 값을 삽입할 때, 원본과 사본의 관계를 설명함
    
- 사본을 통해 원본의 정보를 확인할 수 있다고 강조함
    
- 삽입된 값이 원본의 값과 다를 경우, 원본의 정보를 지우고 사본을 사용할 수 있다고 설명함
    
- 원본과 사본의 관계를 명확히 하여, 보안을 강화할 수 있다고 강조함
    
- 사본을 통해 원본을 확인할 수 있는 것이 중요하다고 설명함
    

6-3.조인과 뷰의 관계

- 조인을 통해 뷰에 값을 삽입할 때, 원본과 사본의 관계를 설명함
    
- 조인을 사용한 뷰에서 값을 삽입할 때, 원본을 변경하면 사본에도 반영이 된다고 설명함
    
- 예시를 통해 조인을 통해 여러 개의 뷰에 값을 삽입할 때, 원본을 변경하면 사본에 바로 반영되는 것을 확인함
    
- 뷰의 참조를 통해 원본과 사본의 관계를 강화할 수 있다고 설명함
    
- 조인을 통해 뷰의 값 삽입을 할 때, 원본과 사본을 모두 변경할 수 있다고 설명함
    

7.테이블 관리

7-1.조인 테이블과 뷰

- 무인 테이블 생성 시 기본 테이블 4개 사용함
    
- 조인 테이블과 조인을 이용한 사본 테이블 생성을 설명함
    
- '프로젝트 업데이트' 기능을 사용해 테이블과 뷰를 함께 생성하고 관리함
    
- '수정 가능한 테이블' 기능을 통해 원본 테이블을 변경할 수 있음
    
- '블록 오프' 기능을 통해 뷰의 변경 사항을 저장하고, '해시 테이블' 기능을 통해 뷰를 생성해 테이블을 저장함
    

7-2.뷰를 통한 값 변경

- '뷰를 통한 값 변경'을 설명하며, 뷰를 통해 특정 행의 값을 삽입하거나 수정하는 것을 지양함
    
- 조인 테이블의 경우, '고유한 키'를 통해 값을 변경할 수 있지만, '다중 키'를 통해 값 변경이 불가능함
    
- 뷰를 통해 값을 변경하는 것은 허용되지 않으며, 특히 '조인 테이블'을 이용할 때는 더욱 주의해야 함
    
- '위키리다' 기능을 통해 뷰를 통해 값을 변경하는 것을 가능하게 함
    
- 뷰를 이용한 값 변경은 '존재하는 테이블'을 이용한 값 변경과 다름
    

7-3.테이블 삭제와 관리

- '테이블 삭제'를 통해 테이블과 뷰를 모두 삭제하는 것을 설명함
    
- 뷰를 생성할 때 '대조본 관계'를 사용하는 것이 좋으며, '항목 간 관계'를 사용하면 안 됨
    
- 뷰를 삭제할 때는 '프로젝트 업데이트' 기능을 사용해 원본 테이블에 영향을 주지 않도록 함
    
- 테이블을 저장할 때 '해시 테이블' 기능을 사용해 테이블의 변경 사항을 저장함
    
- 원본 테이블에 직접 값을 변경하는 방식이 권장되며, 뷰를 통한 값 변경은 지양해야 함
    

8.테이블 활용

8-1.테이블과 뷰

- 본문에서 테이블과 뷰에 대해 설명함
    
- 뷰의 속성 중 조인과 뷰의 참조에 대해 강조함
    
- 뷰를 이용해 데이터를 효율적으로 다루는 방법을 소개함
    
- 뷰의 일부를 다른 뷰에 두는 방법을 설명함
    
- '그리기' 메소드를 통해 뷰의 일부를 다른 뷰에 레이아웃을 설정하는 방법을 제시함
    

8-2.테이블 조작

- '그리기' 메소드를 활용한 테이블 조작 방법을 소개함
    
- '그리기' 메소드의 각 인자에 대해 자세히 설명함
    
- '그리기' 메소드를 활용해 테이블의 모든 열을 조정하는 방법을 제시함
    
- 조건에 따라 열의 순서를 변경하거나, 일부 열을 가로지르는 방법을 설명함
    
- '그리기' 메소드를 통해 다른 뷰에 레이아웃을 설정하는 방법을 다시 한번 강조함
    

8-3.함수와 사례

- '포켓', '리어', '먼스'와 같은 SQL 함수와 윈도우 함수에 대해 설명함
    
- SQL 함수를 활용한 데이터 분석에 대해 소개함
    
- '포켓'과 '리어' 함수를 활용해 데이터의 특성을 분석하는 방법을 제시함
    
- '먼스' 함수를 통해 데이터의 변환과 변형을 구현하는 방법을 설명함
    
- 다양한 함수들을 활용해 데이터를 효율적으로 다루는 방법을 마지막으로 강조함
    

9.데이터 분석에서의 순위 함수 활용

9-1.순위 함수의 이해와 사용

- 순위 함수는 데이터를 일정한 기준에 따라 정렬하고 위치를 부여하는 함수
    
- 랭크, 오더바이, 비교바이 등 다양한 순위 함수 존재
    
- 각 순위 함수는 사용하는 기준에 따라 다르게 적용
    
- 비교 바이 함수는 두 값의 차이를 기준으로 순위를 결정
    
- 오더바이 함수는 특정 기준에 따라 데이터를 순위대로 정렬
    

9-2.순위 함수의 세부 기능과 활용

- 순위 함수에는 위치 함수, 중간 순위 함수, 최고/최저 순위 함수 등 다양한 기능이 존재
    
- 위치 함수는 값이 얼마나 뒤따라 있는지를 나타내며, 위치가 뒤따라 있을수록 높은 순위를 가짐
    
- 중간 순위 함수는 두 개의 값 사이에 얼마나 있는지를 나타내며, 중간값은 두 값의 평균
    
- 비교 바이 함수는 두 값의 차이를 기준으로 순위를 결정하며, 이 차이가 크면 순위가 높음
    

9-3.순위 함수의 실용적 활용 예시

- 각 순위 함수는 다양한 상황에서 활용 가능
    
- 예를 들어, 데이터를 주고 그 순위를 계산하는 경우, 랭크 순위 함수를 활용해 볼 수 있음
    
- 이를 통해 어떤 항목이 어느 순위에 속하는지 파악 가능
    
- 비교 바이 함수를 활용하여 두 값의 차이를 통해 순위를 파악하는 방법도 가능
    
- 이 외에도 오더바이 함수를 활용하여 중간 순위를 비우고, 숫자형으로 똑같은 값에 대해 같은 순위를 부여하는 방법 등 다양한 활용 가능
    

10.스크립트 코드와 업무의 효율적 진행 방안

10-1.스크립트 코드 작성과 문제점 이해

- 스크립트 코드 작성에 약점이 있어 눈물에 약함
    
- 주어진 작업을 일관성 있게 진행하기 위해 여러 개의 인공지능 자격증을 취득함
    
- 작업이 끝난 후 퇴사한 직원이 다시 투입되어 비품기가 생김
    
- 작업량이 많아질수록 작업의 효율이 떨어짐
    

10-2.자동화 알고리즘에 대한 고찰

- 인도 검수에 대한 문제가 많이 발생함
    
- 각 직원에게 적합한 연봉을 부여하기 위해 합리적인 인도 검수 시스템 필요
    
- 각 직원의 연봉은 그들의 업무 성과에 따라 달라짐
    
- 자동화 알고리즘을 통해 연봉을 최적화 할 수 있음
    

10-3.효율적인 업무 분배와 수행

- 윈도우 함수를 이용하여 작업을 효율적으로 분배
    
- 랭크, 밀집도, 로우 넘버 등 다양한 윈도우 함수를 이용하여 업무의 효율을 높임
    
- 로우 넘버 함수는 동일한 값에 대해서 순위를 매겨서 가장 낮은 순위를 부여
    
- 각 윈도우 함수를 적절히 사용하여 업무 분배와 성과를 최적화
    

11.파티션별 임금산출

11-1.파티션별 임금 계산

- 연봉을 계산해 파티션 기준으로 분배함
    
- 부서별 셀러리를 퍼스트 밸류로 출력함
    
- 가장 많이 받는 부서별 임금을 확인할 수 있음
    
- 구간을 나누어 작성하면 부서별 매기값을 얻을 수 있음
    
- 파티션별 윈도우에서 가장 먼저 나온 값을 기준으로 정렬함
    

11-2.윈도우 함수

- 파티션별 윈도우에서 가장 작은 값부터 기준으로 정렬함
    
- 생략 가능한 경우는 전체 회사의 임금으로 대체함
    
- 집계함수를 작성할 때, 기준을 넣어주지 않으면 오류가 발생함
    
- 윈도우 함수를 사용하면, 긴 서브 커리를 작성할 필요가 없어짐
    
- 매번 행을 계산하며, 제일 먼저 리턴한 행이 현재 파티션의 마지막 행임
    

11-3.윈도우 절의 작성

- 윈도우 절을 작성할 때, 시작 구간과 끝 구간을 정하고 매개변수를 넣음
    
- 규칙을 넣어 두 개 이상의 값을 갖는 경우, 마지막 값을 기준으로 함
    
- 첫 번째 행부터 마지막 행까지, 순서대로 나누어 작성함
    
- '파티션 바이'를 기준으로 각 구간을 묶어서 출력함
    
- 마지막 값을 기준으로 구간을 나누어 작성하면, 매번 마지막 행의 값을 리턴함
    

12.업무 성과 평가 시스템

12-1.업무 성과의 척도 설정

- 업무 성과를 측정하기 위해 직원의 연봉, 업무량 등 다양한 요소를 고려함
    
- 이를 평가 기준으로 설정하고 각 요소에 대한 비율을 결정함
    
- 분산, 표준편차 등 측정 값들을 활용하여 측정 정확성을 높임
    
- 계산한 성과 평가 점수에 따라 상위/하위 직원으로 선정함
    

12-2.업무 성과 평가 시스템 설명

- "에러 메시지"라는 하나의 값으로 직원 평가 결과를 집계함
    
- 파티션 기준으로 직원을 구분하고 각 그룹에 대한 평균 임금을 계산함
    
- 최저임금과 최고임금을 포함해 각 그룹에 대한 평균 임금을 계산함
    
- 각 그룹의 평균 임금이 기준이 되어질 수 있도록 함
    

12-3.업무 성과 평가 시스템의 향상

- 셀러리 기준을 변경하여 평가 시스템의 정확성을 높임
    
- 이를 통해 개인의 업무 성과를 더욱 명확하게 평가하고, 공정한 평가 결과를 도출함
    
- "이전 몇 행의 값을 가져오는 함수"라는 새로운 시스템을 도입하여 더욱 효율적인 평가 시스템을 구축함
    
- 이를 통해 회사의 업무 성과를 더욱 정밀하게 평가하고, 경쟁력 있는 인사 시스템을 구축함
    

13.영화의 상영관 분석과 연론을 계산

13-1.영화 상영관 분석을 위한 준비 과정

- '스쿠시와 포드시'를 통한 강등에 따른 연봉 변동을 분석함
    
- '아담스 씨'의 월급을 통해 스미스 씨의 월급을 계산
    
- 무수행인 경우로 조건에 대한 출력값을 확인
    
- 없는 자리에 대해 0으로 처리할 조건을 만들기 위해 인자로 넣어 놓음
    

13-2.SQL을 이용한 영화 상영관 분석

- 박스오피스에서 영화 상영관 수를 최다로 만든 상황을 생성
    
- 최다 상영관 수를 가진 영화의 상영관수를 출력하는 함수를 만듬
    
- ' 파티션과 1'을 이용하여 결과를 간결하게 표현
    
- 함수를 통해 각 영화의 스크린을 확인하고, 이를 통해 상영관 순위를 매김
    

13-3.영화 순위에 대한 수정 및 보정

- 먼저 순위를 매긴 후, 이를 다시 업데이트하여 개봉년도를 확인
    
- 최고 상영관 수를 가진 스크린을 생성하고, 이를 다시 수정하여 순위를 매김
    
- '오더바이' 함수를 이용하여 순위를 매김
    
- 간선 없이 '최고 상영관 수'만을 출력하도록 수정