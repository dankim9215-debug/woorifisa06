교재

[Day1. 환경설정 & 파이썬 프로그래밍 기초](https://www.notion.so/Day1-2d8efd73348980ecb103f79a78a433d0?pvs=21)

### 1. AI 및 개발 생산성 향상 사례

**1-1. LLM & API를 활용한 사이드 프로젝트**

- LLM(대형 언어 모델)과 API를 활용한 **그림일기 앱 개발 사례** 소개 (00:00~01:48)
- 챗GPT, 스테이블 디퓨전 등 **최신 AI 도구를 조합해 프로토타입을 빠르게 만드는 경험** 공유 (00:57~01:48)
- 핵심 포인트
    - “완성도 높은 서비스”보다 **빠르게 만들어보고, 고쳐 나가는 경험**이 중요
    - 텍스트 → 이미지, 텍스트 → 코드 등 **멀티 모달 도구 조합**에 익숙해질 것

**1-2. 프로젝트 경험 쌓기 전략**

- 프로젝트 경험이 없으면, **스터디 모임을 통해 미니 프로젝트를 반복**해볼 것 권장 (02:42)
- 처음부터 대형 서비스를 목표로 하기보다:
    - 1~2주 안에 끝낼 수 있는 작은 프로젝트 여러 개
    - 기능 하나씩 늘려가는 방식으로 난이도 조절
- AI 엔지니어로 취업한 사례 언급 (02:42~03:36)
    - 팀 내 협업 경험, 코드 리뷰, 책임감 있게 일한 경험 강조
    - “**실제 협업 경험** + **작게라도 끝까지 만들어본 경험**”이 강력한 포트폴리오가 됨

---

### 2. AI 및 개발 관련 도구와 서비스 활용

**2-1. AI 어시스턴트 & 검색 도구**

- 코드/문서/아이디어 생성에 활용 가능한 도구들 안내 (04:36~05:35)
    - **GitHub Copilot**
    - **ChatGPT**
    - **Gemini**
    - **Claude**
    - **Perplexity** 등
- 활용 방향
    - 초안 작성, 코드 스캐폴딩, 리팩토링 아이디어, 테스트 코드 생성 등에 적극 활용
    - “처음부터 혼자 다 하려 하지 말고, AI를 **페어 프로그래머**처럼 사용”

**2-2. 검색 특화 도구**

- **Perplexity**
    - 검색 결과마다 **출처 링크를 명시**해 신뢰도 확보 (05:35~07:32)
    - 복수의 출처를 요약해 주어, 개념·기술 비교에 유리
- **Stack Overflow**
    - 전통적인 개발자 Q&A 플랫폼
    - 에러 메시지/구체적인 코드 이슈 검색에 특화
- **Bigtab / Bigtove 등 코드 검색 엔진** (빅터브로 언급된 부분)
    - **코드/프로젝트 레포지토리 검색 및 아이디어 탐색**에 유용 (06:42~07:32)
    - 특정 기술 스택(React, Spring, FastAPI 등)로 구현된 예제 프로젝트를 빠르게 찾을 때 사용

---

### 3. 개발 트렌드 및 정보 습득 방법

**3-1. 뉴스레터 & 슬랙 연동**

- 최신 개발 트렌드 파악용 추천
    - **빅뉴스**, **커리어리** 등 개발/커리어 관련 뉴스레터 (08:25~09:15)
    - 슬랙과 연동해 **지정 채널로 자동 수신** → 매일 자연스럽게 피드 소비
- 장점
    - 굳이 검색하지 않아도 **중요 이슈·트렌드를 큐레이션** 받아볼 수 있음
    - 아침 출근/등원 시간에 가볍게 훑어보기 좋음

**3-2. 면접 대비용 트렌드 공부**

- 면접에서는 “모든 걸 깊게 아는 것”보다
    - **최근 키워드/트렌드에 대해 기본 개념을 알고, 아는 척이라도 자연스럽게 할 수 있는 수준**이 중요 (10:08~12:06)
- 예시
    - “최근에 관심있게 본 기술/서비스가 있나요?”
    - “요즘 프론트엔드/백엔드/AI 쪽 이슈 중에 기억나는 게 있나요?”
- 뉴스레터, 기술 블로그, 커뮤니티를 통해 **얕고 넓은 지식 풀**을 유지해두기

**3-3. Developer Roadmap 활용**

- 사이트: **[로드맵.sh](http://xn--hy1bj0ed9a.sh) (developer roadmap)** (12:06~14:05)
    - 프론트엔드, 백엔드, DevOps, AI 등 **직무별 학습 로드맵** 제공
- 활용 방법
    - “내가 지금 어디쯤 와 있는지” 체크
    - 다음에 무엇을 공부해야 할지, **학습 우선순위를 정할 때 참고용**으로 사용
    - 전부 다 할 필요는 없고, **회사/관심분야에 맞는 가지**를 골라 집중

---

### 4. 포트폴리오 및 프로젝트 경험의 중요성

**4-1. 다양한 형태의 프로젝트 경험**

- 포트폴리오에 담을 수 있는 활동 예시 (14:39~15:38)
    - 사이드 프로젝트
    - 부트캠프/학원 파이널 프로젝트
    - 기술 세미나 발표, 스터디 발표
    - 해커톤, 공모전 등
- 중요 포인트
    - **규모보다 완성도, 완성도보다 “끝까지 해본 경험”**
    - 기능이 적어도, 문제 정의 → 설계 → 구현 → 배포 → 회고까지 한 사이클을 경험하는 것이 핵심

**4-2. AI 도구를 활용한 빠른 실습**

- 프로젝트 경험이 부족해도:
    - ChatGPT, Claude 등 AI 도구를 활용해 **기획·설계·코드 생성을 빠르게 반복** 가능 (14:39~15:38)
- 예시
    - “로그인 기능이 있는 간단한 ToDo 앱 설계해줘” → 설계 검토
    - “이 설계대로 Node.js/Flask/React로 기본 뼈대 코드 만들어줘”
    - 만들어진 코드를 이해하며 수정·기능 추가 → 포트폴리오로 활용

---

### 5. Git 및 GitHub를 활용한 형상관리

**5-1. Git & GitHub 기본**

- **Git**: 소스 코드의 변경 이력을 관리하는 **분산 버전 관리 시스템** (15:38~20:22)
- **GitHub**: Git 저장소를 원격으로 호스팅하는 서비스
- 기본 흐름
    1. Git 설치 & GitHub 가입
    2. 로컬 폴더에서 `git init`으로 저장소 초기화
    3. 변경된 파일을 `add` → `commit` 로 버전 기록
    4. GitHub 원격 저장소(remote)에 `push`로 업로드

**5-2. 프로젝트 단위 관리 & 브랜치 전략**

- 하나의 **폴더/프로젝트 단위로 Git 저장소를 관리** (21:10~22:52)
- 브랜치 개념
    - `main`(또는 `master`): 기준이 되는 메인 브랜치
    - 기능/실험 단위로 `feature/login`, `feature/ui` 등의 브랜치 생성
- 협업 시 브랜치 전략
    - 각자 브랜치에서 작업 → PR(Pull Request)로 `main`에 머지
    - 충돌 발생 시, Git이 표시해 준 부분을 수동으로 수정 후 재커밋

**5-3. 원격 저장소 & 충돌 관리**

- 원격 저장소(리모트 레파지토리)
    - GitHub 주소를 `origin`이라는 별명으로 등록 (`git remote add origin ...`)
    - `git push origin main` 으로 메인 브랜치 업로드 (22:52~43:28)
- 충돌 관리
    - 다른 사람이 수정한 내용과 내가 수정한 내용이 겹치면 충돌 발생
    - VS Code/Git이 충돌 구간을 표시 → 어떤 내용을 남길지 선택 후 커밋

**5-4. VS Code와 Git 연동**

- VS Code에서 Git 탭/소스 제어 기능을 활용해 (44:33~47:25)
    - 변경된 파일 확인
    - 커밋 메시지 입력
    - 브랜치 전환, 푸시/풀 등 GUI로 사용 가능
- CLI에 익숙하지 않아도, **VS Code를 통해 Git 기본 작업 수행** 가능

---

### 6. 개발 환경 설정 및 실습 팁

**6-1. 파일/확장자 표시 설정**

- 윈도우 탐색기에서:
    - **숨김 파일 보기**
    - **파일 확장자 표시**
- 설정 이유
    - `.git`, `.env` 등 숨김 폴더/파일 확인
    - `.py`, `.js`, `.md` 등 확장자를 보고 파일 타입을 정확히 인지 (46:29)

**6-2. Git 설치 후 VS Code 재시작**

- Git 설치 후에는 VS Code를 **한번 종료 후 재시작**해야
    - VS Code가 Git 설치를 인식하고, Git 관련 메뉴/기능 활성화 (49:00)

---

### 7. “사용자 업데이트” 개념 (변경 이력 기록)

> 이 부분은 강의에서 사용한 특정 툴/시스템의 용어로 보이지만,
> 
> **Git 커밋/히스토리와 매우 비슷한 개념**이라고 이해하면 됨.

**7-1. 파일 수정과 추적 (사용자 업데이트)**

- 파일 수정사항을 기록하는 용도로 **‘사용자 업데이트’ 명령어** 사용
- 이 명령어로 파일을 변경하면, **변경 내용이 메시지 형태로 로그에 남음**
- “클립”이라는 인터페이스에서 이 명령 기반의 변경 이력을 확인 가능
- 기존 명령어로 파일 변경 시, **이전 상태의 변경사항을 기억**해 줌
- 명령어에 의한 파일 수정의 증거를 **‘기타 변경 사항’ 메시지**로 남김

**7-2. 파일 변경 확인**

- 기존 파일에 수정이 생기면, 항상 **‘기타 변경 사항’ 메시지를 추가**로 남김
- 이 메시지에는:
    - 어떤 파일에
    - 어디(삽입 위치)에
    - 어떤 변경이 있었는지 등의 정보가 포함
- 시스템은 기존 파일의 모든 변경 사항을 기억한 뒤, 새로운 파일 업로드를 허용
- 업로드 시, ‘사용자 업데이트’ 명령어로 변경사항이 반영되며, 이 역시 **메시지로 기록**

**7-3. 파일 업로드 확인**

- ‘사용자 업데이트’를 통해:
    - 기존 파일이 변경되었고
    - 새로운 파일이 업로드되었다는 사실을 명시적으로 기록
- 업로드 프로세스
    1. 기존 파일의 변경 사항을 먼저 업로드
    2. 그 다음 새로운 파일 업로드
- 이 과정 전체가 **‘기타 변경 사항’ 메시지로 로그에 남아, 추후 추적 가능**

---

### 8. 변경사항 관리 (로컬 & 원격)

**8-1. 로컬 환경에서의 변경사항 관리**

- 사용자가 로컬 환경에서:
    - 파일 이름을 지정하고
    - 변경사항을 자율적으로 관리
- ‘디렉토리’ 메뉴 → ‘상태’ 탭 → ‘기록 상태’로 변경
    - 현재/과거/향후 변경사항을 한 화면에서 확인 가능
- 상태 분류
    - **현재(Current)**: 지금 반영된 상태
    - **이전(Previous)**: 과거 버전
    - **추적(Tracked)**: 추적 중인 변경사항/메모리
- 파일과 메모리 상황을:
    - ‘현재 상황’
    - ‘이전 상태’
    - ‘추적 메모리’ 로 나누어 표현 → 히스토리 관리에 도움

**8-2. 브랜치 개념과 원격 레파지토리**

- 폴더 단위로 파일이 겹치지 않게 관리하거나, **브랜치 개념을 활용**해 상태 분리
- 브랜치를 활용하면:
    - 동일한 디렉토리를 서로 다른 상태로 나누어 사용 가능
    - 예: 실험용 vs 안정 버전
- 메인 브랜치는 기본적으로 제공되며, 별도 설정 없이 사용 가능
- 원격 레파지토리 연결
    - 리모트 레파지토리를 추가하고 **‘origin’**이라는 별명 사용
    - Git의 `origin`과 개념적으로 동일

**8-3. 기존 레포지토리에서의 변경사항 반영**

- 로컬 레포지토리에서 작업 후, 변경사항을 **‘origin’ 메인 브랜치에 업로드**
- 첫 번째 커밋
    - ‘현재 파일’ 상태를 기록
- 두 번째 커밋
    - ‘새로운 파일’ 형상을 기록
    - 예: `hello`와 `test_hello` 두 파일 중
        - `hello` 삭제
        - `test_hello` 유지/수정
- 커밋 히스토리를 통해:
    - 어느 시점에 어떤 파일이 추가/삭제/변경되었는지 추적 가능

---

### 9. 프로젝트 관리 도구 & 마크다운

**9-1. VS Code를 활용한 프로젝트 관리**

- VS Code를 프로젝트 관리 도구로 활용
    - 로컬 코드 편집
    - Git 연동을 통한 변경사항 확인, 커밋, 푸시
- 리포지토리 복사/클론
    - 원격 레포지토리를 클론하여, 다른 폴더/PC에서도 동일 프로젝트 작업 가능
    - 기존 폴더에서 새로운 폴더를 만들어 원격 레포지토리와 연결
- 마크다운으로 작성된 기록(문서)를 VS Code에서 작성/검토

**9-2. 기술 소개: 마크다운(Markdown)**

- 마크다운은 **가벼운 문서 작성 포맷**
    - 프로젝트 문서, README, 회의록 등에 자주 사용
- 특징
    - 제목, 목록, 링크, 이미지 등을 간단한 문법으로 작성
    - 특정 환경(GitHub, Notion, VS Code 등)에서 **자동 렌더링되어 예쁘게 표시**
    - 협업, 버전 관리에 유리 (텍스트 기반)
- 기록 시 장점
    - 변수명, 키워드 등을 검색하기 쉬움
    - 코드 블록, 인라인 코드로 **코드와 설명을 함께 관리** 가능

**9-3. 마크다운을 활용한 기록 관리**

- 마크다운으로 프로젝트 진행 상황을 시각화
- `README.md` 파일 중심으로:
    - 프로젝트 소개
    - 설치/실행 방법
    - 기능 정리
    - TODO, Roadmap 등 관리
- 기존 `.md` 파일을 계속 수정/추가하며:
    - 변경사항을 Git으로 관리
    - 기록을 찾기 쉽고, 버전별로 비교 가능

---

### 10. 마크다운 문서 작성법 (실전 문법)

**10-1. 마크다운 기초 구조**

- 마크다운 프리뷰(예: VS Code 확장)로 **렌더링 결과를 실시간 확인** (프리뷰 인핸스 개념)
    
- 제목(Heading)
    
    - `#` ~ `######` (1~6단계)
        
    - 예:
        
        markdowncopy.label
        
        `# 제목 1## 제목 2### 제목 3`
        
- 내용 구분
    
    - 첫 번째 내용과 두 번째 내용을 구분하고 싶을 때:
        - **수평선** 사용
            
            markdowncopy.label
            
            - `--`
- 강조
    
    - 별(), 언더바(`_`) 등을 이용
        - `기울임*`, `*굵게**`

**10-2. 목록 및 계층 구조**

- 순서 있는 목록 (번호 목록)
    
    markdowncopy.label
    
    `1. 항목 12. 항목 2 1. 하위 항목 2-1 2. 하위 항목 2-2`
    
- 순서 없는 목록 (불릿)
    
    markdowncopy.label
    
    - `항목 A 항목 B 하위 항목 B-1`
- 탭/스페이스로 들여쓰기해서 **계층 구조**를 명확히 표현
    

**10-3. 코드 및 인라인 코드(콤틱)**

- 인라인 코드(콤틱 사용, 백틱 `)
    
    - 일반 텍스트 속에서 `코드` 처럼 표시
- 코드 블록
    
    markdowncopy.label
    
    ````pythonprint("Hello, Markdown")`
    
    textcopy.label
    
- 코드 블록에 언어를 지정하면, **문법 하이라이팅** 적용
    

**10-4. 링크 & 이미지**

- 일반 링크
    
    markdowncopy.label
    
    `[네이버](<https://www.naver.com>)`
    
- 이미지
    
    markdowncopy.label
    
    `![이미지 설명](이미지_주소)`
    
- 느낌표(`!`)가 있으면 **이미지**, 없으면 **텍스트 링크**
    
    - 이미지 링크를 복사하여 `.md`에 삽입하고, Git에 함께 업로드하면 공유 가능

**10-5. 예시 및 수정 흐름**

- 문구를 강조하면서 파이썬 코드로 예시를 포함할 수도 있음
    
    markdowncopy.label
    
    - `*중요:* 아래 코드를 실행하면 결과를 바로 확인할 수 있습니다.```pythonfor i in range(3): print("중요한 코드 예시:", i)`
    
    textcopy.label
    
- 수정 후에는 `.md` 파일을 다시 저장하고, Git에 커밋/푸시하여 **문서 변경 이력**도 함께 관리