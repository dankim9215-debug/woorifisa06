https://colab.research.google.com/drive/1gzJ0Y7uS86YAcK_XkbYW-O75fRG6LetM?usp=sharing

https://paperdoll.notion.site/2e0efd73348980229723d9e319ab2f16?pvs=143

### 1. 함수의 기본 개념

- **함수의 정의**: 입력받은 값을 정해진 명령어 순서대로 처리하여 결과를 돌려주는 명령어의 집합
- **함수의 종류**:
    - **리프 함수(Leaf Function)**: 더 이상 쪼갤 수 없는 최소 기능 단위의 함수
    - **템플릿 함수(Template Function)**: 실행 순서를 규정하기 위해 만든 함수
    - **Getter 함수**: 데이터를 조회하여 보여주는 함수
    - **Setter 함수**: 데이터를 변경하고 원본에 돌려놓는 함수

### 2. 함수 작성법

- **기본 문법**: `def 함수명(파라미터1, 파라미터2, ...):`
- **함수 헤더(Signature)**: 함수명과 파라미터 부분으로, 함수의 고유한 특징을 나타냄
- **함수 독스트링(Docstring)**: 함수 설명을 위한 세 개의 따옴표(`"""`) 사이에 작성하는 문서

### 3. 함수의 종류 (입출력 기준)

- **입력 X, 출력 X**: 단순 실행 후 종료되는 함수
- **입력 O, 출력 X**: 파라미터를 받아 처리하지만 반환값이 없는 함수
- **입력 X, 출력 O**: 파라미터 없이 실행되어 결과를 반환하는 함수
- **입력 O, 출력 O**: 파라미터를 받아 처리하고 결과를 반환하는 함수

### 4. 파라미터와 인자(Argument)

- **파라미터(매개변수)**: 함수 정의 시 사용하는 변수명
- **인자(Argument)**: 실제 함수 호출 시 전달하는 값
- **파라미터 유형**:
    - **기본 파라미터(Default Parameter)**: 값이 제공되지 않을 경우 사용할 기본값 지정
    - **위치 인자(Positional Argument)**: 순서대로 파라미터에 값을 전달
    - **키워드 인자(Keyword Argument)**: 파라미터 이름을 명시하여 값을 전달

### 5. 특수 파라미터 제약

- **/ (Slash)**: 슬래시 앞의 파라미터는 위치 인자로만 사용 가능
- *** (Asterisk)**: 별표 뒤의 파라미터는 키워드 인자로만 사용 가능
- **기본 파라미터 위치**: 기본값이 있는 파라미터는 반드시 기본값이 없는 파라미터 뒤에 위치해야 함

### 6. 반환값(Return)

- **return의 특징**:
    - 함수는 한 번의 실행에서 하나의 return만 실행 가능
    - return 이후 코드는 실행되지 않음
    - 항상 하나의 데이터만 반환 (여러 값은 튜플로 묶여서 하나로 반환)
- **return이 없는 함수**: 결과를 출력만 하고 메모리에 저장하지 않음

### 7. 함수의 메모리 관리

- **함수 호출 시 인자 전달 방식**: 파이썬은 얕은 복사(shallow copy)를 사용하여 메모리 주소를 전달
- **효율적인 함수 작성법**: 불필요한 임시 변수 생성을 최소화하고 직접 반환하는 방식이 메모리 효율이 높음

## 사례/예시

### 1. 기본 함수 예시

python복사

def add(value1, value2):

    return value1 + value2

### 2. 기본 파라미터 사용

python복사

def add(value1, value2=0):

    return value1 + value2

# 사용 예:

add(3)  # value2는 기본값 0 사용

add(3, 1)  # 명시적으로 value2에 1 제공

### 3. 위치 인자와 키워드 인자

python복사

# 위치 인자

add(3, 1)  # 3은 value1, 1은 value2에 할당

# 키워드 인자

add(value2=3, value1=1)  # 순서와 관계없이 명시적 할당

### 4. 특수 파라미터 제약 사용

python복사

def add(value1, /, value2):

    return value1 + value2

# value1은 위치 인자로만 사용 가능

add(3, value2=1)  # 가능

add(value1=3, value2=1)  # 에러: value1은 키워드 인자로 사용 불가

def add(value1, *, value2):

    return value1 + value2

# value2는 키워드 인자로만 사용 가능

add(3, value2=1)  # 가능

add(3, 1)  # 에러: value2는 위치 인자로 사용 불가

### 5. 여러 값 반환

python복사

def add(value1, value2):

    return value1 + 1, value2 + 1

# 사용 예:

result = add(3, 2)  # result는 튜플 (4, 3)

### 6. 효율적인 함수 vs 비효율적인 함수

python복사

# 효율적인 함수: 불필요한 변수 생성 없음

def minus1(a, b):

    return a - b

# 비효율적인 함수: 불필요한 임시 변수 사용

def minus2(a, b):

    result = a - b

    return result

### 1. 타입 힌트(Type Hints)

- **정의**: 함수 매개변수와 반환값에 자료형 정보를 제공하는 기능
- **사용 방법**:
    
    python복사
    
    def add(a: int, b: int) -> int:
    
        return a + b
    
- **특징**:
    - 강제성이 없음 - 실행 시 검사하지 않고 가이드라인으로만 작용
    - 코드 가독성과 문서화에 도움
    - 복잡한 타입은 `List[int]`와 같은 형태로 표현 가능

### 2. 함수와 메서드의 차이

- **함수**: 독립적으로 실행되는 코드 블록
- **메서드**: 특정 자료형에서만 사용할 수 있는 함수
    - 예: `list.sort()` - 리스트에서만 사용 가능한 메서드

### 3. 파괴적/비파괴적 함수

- **파괴적 함수(Destructive)**: 원본을 변경하는 함수 (예: `list.sort()`)
    - 일반적으로 반환값이 `None`
    - 메모리 효율을 위해 설계됨
- **비파괴적 함수(Non-destructive)**: 원본은 유지하고 결과만 반환하는 함수 (예: `sorted()`)
    - 원본 데이터 보존이 필요할 때 유용

### 4. 가변인자

- **위치 가변인자(*args)**: 정해지지 않은 개수의 위치 인자를 튜플로 받음
    
    python복사
    
    def function(*args):
    
        print(args)  # 튜플 형태로 출력
    
- **키워드 가변인자(**kwargs)**: 정해지지 않은 개수의 키워드 인자를 딕셔너리로 받음
    
    python복사
    
    def function(**kwargs):
    
        print(kwargs)  # 딕셔너리 형태로 출력
    
- **언패킹**: `*`를 사용해 튜플/리스트의 요소를 개별 인자로 전달
    
    python복사
    
    def function(a, b, c):
    
        print(a, b, c)
    
    values = [1, 2, 3]
    
    function(*values)  # 1, 2, 3을 각각 a, b, c에 전달
    

### 5. 지역변수와 전역변수

- **지역변수**: 함수 내에서만 유효하며, 함수 종료 시 소멸
- **전역변수**: 프로그램 전체에서 접근 가능한 변수
- **global 키워드**: 함수 내에서 전역변수를 참조하거나 수정할 때 사용
    
    python복사
    
    def function():
    
        global x  # 전역변수 x를 함수 내에서 사용
    
        x = 10
    
- **전역변수 사용 주의**: 코드의 복잡성을 증가시키고 예측하기 어려운 버그 발생 가능성

### 6. 재귀함수(Recursive Function)

- **정의**: 자기 자신을 호출하는 함수
- **작동 원리**:
    - 함수가 스택 메모리에 쌓임
    - 가장 마지막에 호출된 함수부터 역순으로 실행 완료
    - 종료 조건이 필수적으로 필요
- **사용 예**: 팩토리얼, 리스트 평탄화 등
- **주의사항**:
    - 종료 조건이 없으면 무한 재귀(Maximum Recursion Error 발생)
    - 메모리를 많이 사용할 수 있음

### 7. 람다(Lambda) 함수

- **정의**: 이름 없이 간단한 기능을 수행하는 익명 함수
- **사용법**:
    
    python복사
    
    minus = lambda a, b: a - b
    
    print(minus(5, 2))  # 3
    
- **용도**: 간단한 연산을 일회성으로 사용할 때 유용

## 사례/예시

1. **타입 힌트 활용**:
    
    python복사
    
    def fun_reverse(lst: List[int]) -> List[int]:
    
        return lst[::-1]
    
2. **파괴적/비파괴적 함수 비교**:
    
    python복사
    
    li = [3, 1, 2, 4, 5, 11]
    
    li.sort()  # 원본 변경, 반환 없음
    
    sorted(li)  # 원본 유지, 정렬된 새 리스트 반환
    
3. **가변인자 사용**:
    
    python복사
    
    def person_info(**kwargs):
    
        return kwargs
    
    result = person_info(name="김현지", age=22, favorite_numbers=[3, 7, 9])
    
    # {'name': '김현지', 'age': 22, 'favorite_numbers': [3, 7, 9]}
    
4. **재귀함수 예제**:
    
    python복사
    
    def recursive_1(n):
    
        if n > 1:
    
            return n * recursive_1(n-1)
    
        else:
    
            return 1
    
    recursive_1(6)  # 6! = 720
    
5. **리스트 평탄화 재귀함수**:
    
    python복사
    
    def flatten(lst):
    
        result = []
    
        for item in lst:
    
            if isinstance(item, list):
    
                result.extend(flatten(item))
    
            else:
    
                result.append(item)
    
        return result
    
    flatten([1, [2, 3], [4, [5, 6]], 7, 8, 9])  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
    

### 1. 람다 함수(Lambda Function)

- **정의**: 이름이 없는 익명 함수로, 간단한 작업을 수행할 때 사용
- **특징**:
    - 메모리에 함수를 올리지 않고 일회성으로 사용
    - 짧은 코드로 단순한 연산을 수행할 때 유용
    - 재사용할 필요가 없는 간단한 로직에 적합
- **문법**: `lambda 매개변수: 표현식`

python복사

# 기본 람다 함수 예시

add = lambda a, b: a + b

print(add(2, 3))  # 5

# sorted 함수와 함께 사용하는 예

points = [(3, 2), (-3, 2), (0, 1), (1, 1)]

sorted_points = sorted(points, key=lambda x: x[0])  # x좌표 기준 정렬

### 2. 데코레이터(Decorator)

- **정의**: 기존 함수에 기능을 추가하는 파이썬의 문법적 요소
- **특징**:
    - 함수를 인자로 받아 기능을 확장한 새로운 함수를 반환
    - 코드 재사용성을 높이고 중복을 줄임
    - 로깅, 성능 측정, 인증 등 공통 기능을 여러 함수에 적용할 때 유용
- **기본 구조**:

python복사

def my_decorator(func):

    def wrapper(*args, **kwargs):

        # 함수 실행 전 코드

        result = func(*args, **kwargs)

        # 함수 실행 후 코드

        return result

    return wrapper

@my_decorator

def say_hello():

    print("Hello")

### 3. 함수형 프로그래밍

- **정의**: 데이터를 변형하는 함수를 조합하여 프로그램을 구성하는 패러다임
- **특징**:
    - 상태 변경과 가변 데이터를 최소화
    - 코드가 간결하고 메모리 효율적
    - 실행 시점에 값을 생성하는 지연 평가(lazy evaluation) 활용
- **객체지향 프로그래밍과의 차이**:
    - 객체지향: 데이터(변수)와 기능(메서드)을 하나로 묶어 관리
    - 함수형: 데이터를 변환하는 함수들의 조합에 초점

### 4. 리스트 컴프리헨션(List Comprehension)

- **정의**: 리스트를 간결하게 생성하는 파이썬의 문법
- **특징**:
    - 반복문보다 속도가 빠르고 코드가 간결
    - 메모리 효율적인 처리 가능
- **문법**: `[표현식 for 항목 in 반복가능객체 if 조건문]`

python복사

# 기본 리스트 컴프리헨션

squares = [x**2 for x in range(10)]

# 조건문이 있는 리스트 컴프리헨션

even_squares = [x**2 for x in range(10) if x % 2 == 0]

# 중첩 반복문이 있는 리스트 컴프리헨션

combinations = [n+w for n in nums for w in words]

### 5. 파이썬 내장 함수형 도구들

- **map 함수**:
    
    - 시퀀스의 모든 요소에 함수를 적용하여 결과를 반환
    - `map(함수, 시퀀스)`
    - 반환값은 제너레이터(generator) 형태로, 실행 시점에 값 생성
- **filter 함수**:
    
    - 함수가 True를 반환하는 요소만 걸러내는 함수
    - `filter(함수, 시퀀스)`
    - map과 달리 조건이 참인 요소만 반환
- **enumerate 함수**:
    
    - 반복 가능한 객체의 요소와 인덱스를 함께 반환
    - `enumerate(시퀀스)`
    - `(인덱스, 값)` 형태의 튜플로 반환
- **zip 함수**:
    
    - 여러 시퀀스를 병렬로 묶어 튜플의 시퀀스로 반환
    - `zip(시퀀스1, 시퀀스2, ...)`
    - 가장 짧은 시퀀스 길이에 맞춰 결과 생성

## 사례/예시

1. **리스트 컴프리헨션 vs 반복문 성능 비교**:

python복사

# 반복문 방식 (느림)

list1 = []

for i in range(1, 70001):

    list1.append(i)

# 리스트 컴프리헨션 방식 (빠름)

list2 = [i for i in range(1, 70001)]

2. **맵 함수를 이용한 데이터 변환**:

python복사

# 리스트의 모든 요소에 10 더하기

numbers = [1, 2, 3, 4, 5]

result = list(map(lambda x: x + 10, numbers))  # [11, 12, 13, 14, 15]

3. **필터 함수를 이용한 데이터 필터링**:

python복사

# 짝수만 필터링

def even(x):

    return x % 2 == 0

numbers = [1, 2, 3, 4, 5]

even_numbers = list(filter(even, numbers))  # [2, 4]
