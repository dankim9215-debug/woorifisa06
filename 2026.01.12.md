https://paperdoll.notion.site/NumPy-175efd733489811aa1a8e8bd10c0990a
https://colab.research.google.com/drive/1QS3HXGvT5aRgZRxv0AZp0u5BbANp3mBX?usp=sharing

메모: Numeric Python 의 약자. NumPy 파이썬의 리스트와 닮아있음


1.파이썬과 넘파이를 이용한 데이터 처리

1-1.파이썬과 넘파이의 소개 및 설치

- 파이썬과 넘파이는 모두 컴퓨터 프로그래밍 언어로써 데이터를 다루는 도구임
    
- 파이썬은 기초적인 프로그래밍 언어로 인터프리터를 통해 원하는 결과를 도출함
    
- 넘파이는 보다 고급적인 데이터 처리 도구로, 데이터를 일괄 처리하며 다른 데이터에 공통 요건을 적용할 수 있음
    
- 이 두 도구는 프로그래밍 언어로서 유저의 작업을 편리하게 만들어주는 도구임
    

1-2.넘파이의 사용과 설치

- 넘파이는 구글 드라이브를 통해 복사 및 설치 가능하며, 기본 패키지인 '기초 특강'에서 찾아볼 수 있음
    
- 그 이후에 코랩에서 제공하는 '파이썬 공개' 도구를 통해 설치 가능
    
- 하지만, 코드를 직접 작성하려는 사용자도 있음
    
- 복잡한 작업을 수행하려면, 직접적으로 넘파이 도구를 이용해야 하는 경우도 있음
    

1-3.간단한 예제를 통한 데이터 처리

- 간단한 데이터 처리 예제를 통해, 넘파이 도구를 활용한 데이터 처리 과정을 이해할 수 있음
    
- 이 예제에서는 '테스트'라는 리스트의 값을 더하는 과정을 수행함
    
- 이 예제를 통해, 넘파이 도구를 사용해 특정 순서로 데이터를 처리하고, 다른 데이터에 대해 동일한 작업을 수행할 수 있음을 알 수 있음
    
- 또한, '컴퓨터' 도구를 사용하면, 파이썬 도구보다 빠른 처리가 가능함을 알 수 있음
    

2.데이터 처리

2-1.리스트 자료형과 한계

- 파이썬에서 사람들이 많이 사용하는 자료형인 리스트 자료형을 설명함
    
- 리스트 자료형은 원소 단위로 돌면서 값을 움직이기 때문에 배열의 여러 원소들을 동일한 방식으로 작업할 수 있음
    
- 리스트에 30점을 추가하려면 값을 하나씩 추가하거나 여러 개의 리스트를 넣어 주는 등의 방식으로 동작함
    
- 여러 개의 원소들을 끄집어내서 평균을 구할 때, 처음부터 다시 모든 원소들을 동일한 방식으로 작업해야 하므로 불편함이 있음
    
- 반복된 작업을 생략하기 위해 람다 모듈이나 함수를 사용할 수 있음
    

2-2.넘파이 패키지의 장점

- 넘파이는 다차원 배열 작업을 효율적으로 할 수 있도록 지원함
    
- 넘파이는 내부적으로 파이썬 코드를 작성하고 인터프리터를 통해 실행하는 방식을 취함
    
- 연산 속도가 빠르고, x축과 y축을 2차원으로 표현 가능함
    
- 내장 함수들을 하나의 명령어로 연산하기 때문에, 코드의 길이가 길어질 수 있음
    
- 데이터 처리 업무를 반복적으로 수행할 때, 이러한 다차원 배열 작업을 통해 긴 코드와 낭비할 수 있음
    

2-3.넘파이 패키지의 적용

- 넘파이는 R, G, B 세 가지 색을 교차시켜 빛의 삼원색으로 나타내는 등의 다양한 데이터 처리가 가능함
    
- 소리 데이터 또한 주파수 음역대를 가지고 있으며, 이 또한 숫자로 변환되어 다차원 배열이 됨
    
- 넘파이는 이러한 데이터를 처리할 때, 데이터를 1차원, 2차원으로 표현하여 다차원 배열을 통한 연산을 수행함
    
- 다차원 배열을 하나씩 원소 단위로 돌면서 평균을 계산하는 등의 작업을 생략할 수 있음
    
- 이러한 다차원 배열 작업을 통해 긴 코드와 낭비할 수 있음
    

3.데이터 처리와 파이썬의 리스트와 행렬

3-1.데이터 처리와 메모리 관리

- 데이터 처리에서의 '깊이'는 특정 기준으로 데이터를 받아볼 때, 그 깊이에 따라 데이터를 처리함
    
- 넘파이에서는 행렬의 연산을 내부적으로 파이썬의 리스트에 저장함
    
- 메모리의 각 원소 값들은 서로 다른 메모리 공간에 저장되며, 이를 통해 데이터를 처리함
    
- 파이썬의 리스트는 메모리 하나하나의 기본 자료형이 들어가며, 넘파이에서는 일괄적으로 저장함
    

3-2.파이썬의 리스트와 네임스페이스의 사용

- 넘파이에서 '테스트'라는 별도의 인쇄를 만들어 놓음
    
- 테스트는 여러 작업들을 빠르게 돌리는데 사용되며, 여기에는 여러 가지 데이터 처리 기능이 포함됨
    
- 파이썬의 리스트에서는 하나하나의 원소에 대한 작업을 일괄적으로 처리함
    
- 넘파이에서는 일괄적으로 처리하는 것이 아닌, 원하는 행렬 작업을 수행하고 결과를 반환함
    

3-3.넘파이 패키지의 불러오기와 활용

- 넘파이 패키지는 '미리 패키지'에서 불러옴
    
- 'MPA'라는 자료형을 사용하여 여러 작업들을 더욱 빠르게 수행함
    
- 나머지 패키지들은 나머지 작업들을 더 간단하게 만들기 위해 사용됨
    
- 불러온 패키지에서 '테스트'라는 별도의 인쇄를 만들어 놓음
    
- '테스트'는 여러 작업들을 빠르게 돌리는데 사용되며, 여기에는 여러 가지 데이터 처리 기능이 포함됨
    

4.리스트와 다차원 배열

4-1.리스트의 특징과 활용

- 리스트의 기본적인 특징과 활용을 설명함
    
- 리스트에서 각 요소는 순차적으로 저장되며, 특정 순서에 삽입이나 삭제가 가능함
    
- 여러 가지 함수와 메소드를 제공하여 데이터를 처리하고 분석할 수 있음
    
- 다양한 연산들을 하기 위해 메소드들을 많이 내장하고 있음
    
- 파이썬의 리스트와 달리 넘파이에서는 "_append"이라는 메소드를 클래스 메소드로 사용함
    

4-2.다차원 배열의 특징과 활용

- 다차원 배열은 3차원으로 표현되는 큰 공간을 의미함
    
- "참조 배열"이라는 메소드를 통해 다른 요소를 참조할 수 있음
    
- 복잡한 데이터를 다룰 때는 다차원 배열을 사용하여 효율적으로 처리할 수 있음
    
- 추가, 수정, 삭제 등의 데이터 변경 작업이 가능함
    
- 다양한 메소드들을 제공하여 데이터를 다루는 작업을 편리하게 할 수 있음
    

4-3.다차원 배열의 특징과 활용

- 다차원 배열은 여러 개의 배열을 하나의 공간에 연속적으로 저장할 수 있음
    
- 순서대로 값을 저장되면서도 다차원 배열의 메모리 주소는 일정한 순서를 가짐
    
- 다차원 배열의 요소는 메모리 주소의 일정한 공간에 할당되며, 이를 참조하는 메소드가 있음
    
- 파이썬의 리스트와 달리, 다차원 배열은 각 요소를 별도의 공간에 분리하여 저장함
    
- 다차원 배열을 이용하면 다차원 데이터를 효율적으로 다루고 분석할 수 있음
    

5.넘파이 행렬

5-1.넘파이의 배열 이해

- 새로 기존 리스트에 추가하면, 파이썬의 기본 리스트처럼 새로운 메모리 공간을 생성함
    
- 테스트에 값을 추가하는 것이 아니라, 새로운 배열을 만드는 것임
    
- 넘파이의 리스트는 원래의 배열을 그때그때 필요한 값들을 순서대로 나란히 저장해 둠
    
- 행렬의 연산을 할 때, 차원이 중요한 요소이므로 행렬의 차원을 정할 때 주의해야 함
    
- 사이킷런을 통해 일관된 데이터로 학습할 때, 메모리가 한 개씩 끊어주어 연산이 빠르게 돌아감
    

5-2.넘파이의 자료형 내부 구현

- 넘파이의 '사이즈'는 '원소의 크기'를 의미함
    
- '나열'과 '사이즈' 명령어를 통해 행렬의 크기와 원소의 개수를 확인할 수 있음
    
- '나열'은 행렬의 형태, '사이즈'는 행렬의 크기, '순서'는 행렬의 순서를 의미함
    
- '스트라이드'는 한 줄을 건너뛰는 보폭, '나열'과 '사이즈'를 함께 사용하여 행렬의 전체 크기를 계산함
    
- '나열'과 '사이즈' 명령어를 통해 행렬의 구조를 확인할 수 있음
    

5-3.예제로 본 넘파이의 활용

- '제목'을 주어받아, 각 방에 원소를 넣어 '사용'함
    
- 각 방에 '인간'을 4바이트로 할당, '직위'에 '직위'를 16바이트로 추가하여 총 30바이트의 메모리로 할당함
    
- 넘파이는 '제목'을 통해 각 방의 값을 직접 확인할 수 있음
    
- 넘파이는 '사용' 명령어를 통해 데이터를 메모리에 저장할 수 있음
    
- 넘파이는 '인간'을 통해 데이터를 메모리에 저장하고, '제목'을 통해 데이터를 확인할 수 있음
    

6.메모리 관리와 배열의 이해

6-1.메모리 관리와 배열의 기본 이해

- 메모리 배열은 원소 하나에 8바이트 할당되며, 이를 넘어서는 값을 가지지 않음
    
- 원소 하나를 넘어서는 값은 다음 원소로 넘어가며, 이는 8바이트로 정해져 있음
    
- 메모리 주소에서 00으로 시작하는 메모리 주소라면, 8바이트가 넘어가야 다음 원소의 1차원이 생성됨
    
- 메모리 배열을 이용하여 값을 추가하거나 자료형을 변경하면서 어떤 값이 변하는지 확인 가능
    

6-2.메모리 배열의 조작과 장단점

- 메모리 배열의 방 하나의 크기는 8바이트로 제한되어 있음
    
- 메모리 배열에서 데이터를 일괄적으로 작업하고, 각 원소 하나에 할당된 크기로 데이터를 저장
    
- 메모리 배열은 원하는 형식대로 데이터를 잘라 끊어주는 데 있어 속도가 빠름
    
- 하지만 메모리 배열에 데이터를 넣을 때 원하는 자료형으로 변환해야 하며, 이는 메모리 공간의 부담을 유발
    

6-3.메모리 배열의 실용적인 활용

- 메모리 배열은 원소 하나에 8비트를 할당하여 넣을 수 있음
    
- 이 경우, 원소는 4개의 값을 가지며, 원소 하나가 1바이트의 값을 가짐
    
- 메모리 배열에서 값을 넣을 때는 메모리에 공간이 너무 부족하면, 자료형을 변환하거나 임의로 데이터 타입을 변경해야 함
    
- 메모리 배열의 크기를 조절할 때, 메모리 공간의 부담을 고려해야 하며, 이를 메모리의 크기, 데이터의 할당방식 등으로 조절해야 함
    

7.2차원 행렬과 다차원 행렬

7-1.2차원 행렬 이해

- 2차원 행렬은 2열짜리 2차원 데이터로 구성됨
    
- 원소가 차지하는 공간은 2바이트, 자료형은 이차원형으로 설정됨
    
- 원소 전체 개수는 8개임
    
- 한 줄로 데이터를 관리하여, 한 줄의 데이터는 원소 하나씩 띔
    
- 스트라이드는 2차원으로 적용되어, 원소 하나씩을 건너뛰는 과정이 8바이트임
    

7-2.다차원 행렬 이해

- 3차원 행렬은 3열짜리 3차원 데이터로 구성됨
    
- 원소가 차지하는 공간은 3바이트, 자료형은 이차원형으로 설정됨
    
- 원소 전체 개수는 8개임
    
- 한 줄로 데이터를 관리하여, 한 줄의 데이터는 원소 하나씩 띔
    
- 스트라이드는 3차원으로 적용되어, 원소 하나씩을 건너뛰는 과정이 3바이트임
    

7-3.다차원 행렬 결과 확인

- 2차원 행렬의 결과와 동일하게, 원소 개수는 8개임
    
- 3차원 행렬의 결과는 3, 3, 3의 각 열에 3개씩 데이터가 들어있음
    
- 원소의 개수는 8개, 자료형은 이차원형으로 통일됨
    
- 원소 하나가 차지하는 공간은 2바이트, 원소 전체 개수는 8개임
    
- 2차원 행렬과 3차원 행렬은 원소의 개수를 유지하면서 차원을 증가시킴
    

8.간단한 데이터 형식과 그 활용

8-1.데이터 형식과 그 특성 이해

- 숫자 자료형과 문자열 등 다양한 자료형이 있음
    
- 0, 1로 변환되는 숫자 자료형은 '인지 오브젝트'에 해당
    
- 문자열은 모든 자료형을 포괄할 수 있음
    
- 플롯과 민트 등의 자료형은 특정 조건에 따라 변환됨
    
- 특정 자료형으로 변환될 때, 해당 자료형에 맞게 값이 저장됨
    

8-2.일괄적인 자료형 변환과 그 이점

- 일괄적인 자료형 변환은 코드를 줄이고 동작을 간편하게 함
    
- 리스트와 달리, 낱낱이 데이터를 추가하거나 변경할 수 없음
    
- 낱낱이 데이터의 경우, 원소 단위로 특정 동작을 수행해야 함
    
- 일괄적인 자료형 변환은 이런 제한을 없애고 동작을 간편하게 함
    
- 결과적으로 같은 작업을 더 빠르고 효율적으로 수행할 수 있음
    

8-3.일괄적인 자료형 변환의 한계와 주의점

- 일괄적인 자료형 변환은 모든 배열에 동일한 방식으로 작동
    
- 낱낱이 데이터에 추가나 변경이 불가능하므로, 정확한 배열 크기 및 순서를 유지해야 함
    
- 특정 자료형으로 변환할 때, 해당 자료형에 맞게 배열이 저장되도록 주의 필요
    
- 원소 추가나 변경이 불가능하므로, 배열 내 원소의 순서를 유지해야 함
    
- 일괄적인 자료형 변환으로 인한 결과는 어떤 동작이든 일관되게 보이는 것이 아니라, 원본 자료형의 특성을 유지함
    

9.넘파이 활용

9-1.넘파이의 특징

- 넘파이는 행렬의 연산을 위한 패키지임
    
- 엑시스 축을 기준으로 배열을 복사하여 새로운 메모리에 삽입함
    
- 엑시스가 따로 정해져 있지 않으면, 밸류들은 1차원으로 평탄화됨
    
- 행렬의 0번째 인덱스에 2차원 행렬의 값을 삽입할 때, 개수 맞춰서 넣어야 함
    
- 2차원 행렬의 행과 열을 유지하면서 값을 삽입할 수 있음
    

9-2.행렬의 값 삽입

- 2차원 행렬의 0번째 인덱스에 값을 삽입할 때, 개수 맞춰서 넣어야 함
    
- 원소의 개수가 맞지 않으면 에러 메시지를 남김
    
- 행렬의 차원과 원소의 개수가 일치해야 연산이 가능함
    
- 원소의 개수가 맞지 않으면, 열을 추가하여 맞춰서 넣어야 함
    
- 추가된 열의 순서는 행렬의 순서를 유지함
    

9-3.행렬의 변경

- 행렬의 값을 변경할 때, 개수를 유지하면서 원소의 순서를 변경할 수 있음
    
- 값을 변경한 행렬의 원소를 확인할 수 있음
    
- 열을 추가하거나 삭제하여 원하는 값을 삽입할 수 있음
    
- 원소의 순서를 유지하면서 값을 변경하는 것이 넘파이의 주요 활용 사례임
    

10.행렬과 차원

10-1.3차원 행렬과 개념

- 3차원 행렬의 차원은 행렬의 가장 끝에 있는 원소의 개수로 결정됨
    
- 3차원 행렬을 평행사변형으로 변환하여 다차원 행렬로 나타낼 수 있음
    
- 3차원 행렬의 엑시스를 평행사변형으로 변환한 후, 특정 행렬 축에 맞춰 배열을 해서 저장함
    
- 평행사변형 행렬은 좌표 축에 따라 변환된 행렬로, 좌표의 몇 번째 차원으로 연산이 이루어짐
    
- 3차원 행렬을 소괄호로 표현하면, 행렬의 각 축에 대한 평행사변형 행렬을 의미함
    

10-2.3차원 행렬의 연산

- 3차원 행렬의 연산은 행렬의 각 축에 대해 다른 연산을 수행함
    
- 3차원 행렬의 엑시스를 각 축에 대해 연산할 때, 행렬의 좌표 축을 먼저 고려함
    
- 2차원 행렬의 경우, 행렬의 행과 열을 바꿔서 연산을 진행함
    
- 3차원 행렬의 경우, 각 축에 대해 다른 연산을 수행하고, 마지막에 원소를 추가함
    
- 3차원 행렬의 엑시스를 각 축에 대해 연산한 후, 행렬의 원소를 추가함
    

10-3.3차원 행렬의 결과

- 3차원 행렬의 결과는 10, 20, 30과 같은 차원의 배열로 나타남
    
- 10, 20, 30으로 표현할 수 있는 이유는 행렬의 좌표 축에 맞춰 배열되기 때문임
    
- 3차원 행렬의 각 축에 대해 연산을 수행한 후, 마지막에 원소를 추가함
    
- 3차원 행렬의 엑시스를 변환하여, 10, 20, 30과 같은 3차원 행렬의 배열을 생성함
    
- 3차원 행렬의 연산 결과는 10, 20, 30과 같은 3차원 행렬의 배열이 됨
    

11.데이터 분석과 차원의 재구조화

11-1.데이터와 차원의 개념 이해

- 데이터 분석에서 차원은 원소의 개수를 의미함
    
- 2차원 데이터에서는 각 열은 하나의 원소로 표현됨
    
- 3차원 데이터에서는 행, 열, 차원 각각 한 개의 원소로 표현됨
    
- 데이터의 차원을 재구조화 하면 행, 열, 차원 순서로 데이터를 효율적으로 저장할 수 있음
    
- 데이터 차원 재구조화 시 원소의 개수만 바뀌어도 연산이 가능함
    

11-2.테스트와 재구조화

- 테스트는 리스트의 값을 검증하는 도구임
    
- 2차원 데이터에서 임의의 행을 추가하면 원본 데이터의 구조가 무너질 수 있음
    
- 테스트를 통해 원본 데이터의 구조를 유지하면서 추가 정보를 삽입하거나 제거할 수 있음
    
- 재구조화는 데이터를 특정 차원의 원소로 변환하는 과정임
    
- 재구조화를 통해 데이터의 효율적인 저장과 연산 가능
    

11-3.데이터 차원의 재구조화

- 재구조화는 원소의 개수가 많은 데이터에서 연산 효율성을 높이기 위해 필요함
    
- 재구조화를 통해 데이터를 원하는 차원의 원소로 변환 가능
    
- 필요한 차원의 원소를 빠뜨리거나 추가할 수 있음
    
- 데이터의 차원을 재구조화 시 원소의 개수만 바뀌어도 연산이 가능함
    
- 재구조화를 통해 데이터의 효율적인 저장과 효과적인 연산 가능
    

12.넘파이 데이터 처리

12-1.넘파이 내장 기능 소개

- 넘파이는 다양한 자료형을 다루기에 여러 함수와 명령어가 있음
    
- 테스트, 리지피케이션, 엣저리, 베이지안, 가설검정 등의 기능이 있음
    
- 데이터를 특정 차원으로 맞추거나 평탄화하여 다른 엑시스로 치환 가능
    
- 테스트 명령어를 사용해 배열의 특정 패턴을 확인할 수 있음
    
- 내장 함수 중 하나인 '거꾸로'는 데이터를 뒤집어주는 것임
    

12-2.납득력 있는 수열 만들기

- '다음'과 '이상'을 사용해 수열을 건너뛰거나 조합할 수 있음
    
- '위'와 '해'를 사용해 배열의 위치를 변경할 수 있음
    
- '우위'는 시작 위치, '위험부하'는 종료 위치를 의미함
    
- 시작 위치보다 더 큰 위치를 '하나의 수열'로 만들 수 있음
    
- 시작 위치, 종료 위치, 스텝을 지정해 수열을 생성함
    

12-3.수열과 데이터 처리

- '어지다'는 수열을 만들어 배열에 저장하는 함수임
    
- '사이다'는 배열의 특정 원소를 추가하는 연산임
    
- '서술다'는 배열의 데이터를 저장하는 방법임
    
- '그래프다'는 데이터의 분포를 그림으로 나타내는 방법임
    
- '변수다'는 변수를 저장하는 방법이며, 실제 변수명은 강의에서 언급되지 않음
    

13.넘파이의 기본 메서드

13-1.메서드의 종류와 공유

- 넘파이는 다양한 메서드를 제공하지만, 주로 행렬과 행/열/월 평균 등의 기능을 제공함
    
- 엑시스라는 파라미터를 공유하여 복잡한 로직 없이 메서드를 간단하게 구현 가능함
    
- 엑시스 파라미터는 행렬의 특정 영역(행, 열, 월)의 값을 비교하는 기능을 나타냄
    
- 예를 들어, 엑시스 파라미터로 행별/열별/월별 평균을 구할 수 있음
    
- 메서드의 동작 순서를 바꾸거나 원본 그대로 유지할 수 있음
    

13-2.엑시스 파라미터의 활용

- 엑시스 파라미터는 다양한 자료형을 포함하지만, 주로 숫자의 3가지 종류(양수, 음수, 무수)를 제공함
    
- 이는 다양한 자료형을 포함하므로, 메서드의 행렬에 불필요한 데이터를 넣을 수 있음
    
- 따라서, 프로그래밍에서 사용하는 다양한 자료형에 맞춰 엑시스 파라미터를 변환하는 것이 중요함
    
- 예를 들어, 무수의 2의 7승까지만 값을 갖도록 설정할 수 있음
    
- 이렇게 메서드의 기능을 제한하여 공간의 낭비를 줄일 수 있음
    

13-3.넘파이의 메서드 제공

- 넘파이는 다양한 메서드를 제공하지만, 주로 행렬과 행/열/월 평균 등의 기능을 제공함
    
- 행렬의 특정 영역(행, 열, 월)의 값을 비교하는 엑시스 파라미터를 공유함
    
- 예를 들어, 행별/열별/월별 평균을 구할 수 있음
    
- 평균을 포함한 다양한 메서드는 엑시스 파라미터를 이용하여 계산 가능함
    
- 기타 여러 메서드를 통해 행렬의 특정 영역에 대한 평균을 구할 수 있음
    

14.데이터 타입

14-1.자료형 변환

- 스트링이나 디지털 자료를 문자열로 변환하는 형 변환이 있음
    
- 기본적으로 수식이나 연산을 이용한 자료형 변환은 가능함
    
- 일괄적으로 문자열로 변환하는 형 변환은 불가능함
    
- 플롯이나 기술편집 등 특정 자료형에서 데이터 변환 시, 불타입으로 형 변환이 되어 보낼 수 있음
    
- 함수를 사용한 데이터 변환은 메모리에 데이터를 저장해야 함
    

14-2.일괄 변환의 주의점

- 메모리에 데이터를 저장할 때, 불타입 형 변환을 통해 일괄적으로 저장할 수 있음
    
- 그러나 일괄 변환 시, 원본 데이터의 자료형을 잃어버리게 됨
    
- 따라서 데이터를 전처리할 때, 일괄 변환을 고려하여 자료형을 스트링으로 등록하는 과정이 필요함
    
- 자료형 변환 시, 오류가 발생하면 메모리에 데이터를 직접 저장해야 함
    
- 제너레이터의 스텝마다 데이터의 자료형을 일괄 변환하는 과정이 반복되어, 0을 포함한 데이터가 생성될 수 있음
    

14-3.오류와 주의점

- 자료형 변환 시, 데이터의 형 변환이 불가능한 자료가 섞여 있으면 형 변환이 불가능한 분류 오류가 발생함
    
- 일괄 변환 시, 메모리에 데이터를 저장할 때, 자료형 변환에 오류가 발생할 수 있음
    
- 불타입 형 변환을 고려하지 않고 일괄 변환 시, 원본 데이터의 자료형을 잃어버릴 수 있음
    
- 데이터의 자료형을 확인하여, 일괄 변환을 고려하지 않고 변환할 경우, 오류가 발생할 수 있음을 기억해야 함
    
- 변환 시 오류가 발생하면, 원본 데이터의 자료형을 확인하여, 데이터의 형 변환이 가능한지 다시 한번 고려해야 함
    

15.데이터 변환

15-1.데이터 변환 이해

- 프로그래밍 언어의 자료형에 따라 데이터 변환이 달라짐
    
- 데이터의 자료형을 변환할 때, 반올림이나 버림이 일어날 수 있음
    
- 플롯 형식의 데이터에서, '정사각형'으로 변환할 때 소수점 이하를 버림
    
- 데이터의 크기를 줄이기 위해, 자료형을 플롯 32로 변경할 수 있음
    
- 양자화를 통해 모델의 복잡성을 줄이고, GPU 값의 부담을 줄일 수 있음
    

15-2.데이터 변환 실습

- 피자집에 갔을 때, 유명 인기로 대기 20명이 있었음
    
- 피자집의 인기로 인해 다른 피자집도 유명해짐
    
- 강의에서 언급된 데이터 변환 지식은 넘파이를 포함한 머신러닝, 딥러닝 패키지에서 사용됨
    
- 모델의 가중치를 줄이기 위해, 양자화를 통해 데이터의 크기를 줄일 수 있음
    
- 데이터 변환 시, 비트의 넘침으로 인한 오버플로우 에러가 발생할 수 있음
    

15-3.데이터 변환 오류

- 데이터 변환 시, 값이 넘치면 오버플로우 에러가 발생함
    
- 파이썬에서 데이터 변환 시, 오버플로우 에러를 일으키는 값이 넘어지면 에러가 발생함
    
- 비트의 부호를 포함한 자료형은, 값의 넘침을 방지하기 위해 데이터의 크기를 줄임
    
- 예를 들어, '이제까지의 값'을 '더하기 128으로 형변환' 시, 0부터 255까지의 값을 갖게 됨
    
- '이제까지의 값'을 '인터 8으로 형변환' 시, 음수와 양수를 모두 포함하는 0부터 255까지의 값을 갖게 됨
    

16.데이터 타입과 연산

16-1.다양한 데이터 타입과 그 연산

- 다양한 데이터 타입 (실수, 정수, 불리언, 복소수) 을 이해함
    
- 연산 시 데이터 타입에 따라 차원과 연산 방식이 달라짐을 인지함
    
- 불리언 타입은 0과 1, 스칼라 값은 동일한 데이터 타입으로 연산됨
    
- 복소수 타입은 실수와 허수를 포함한 복소수 값으로 표현됨
    
- 복소수 타입은 스칼라 값으로도 연산이 가능함
    

16-2.자료형 변환과 에러

- 자료형 변환 시, 배열에 원하는 데이터 타입을 넣어야 함을 설명함
    
- 255를 넘는 값을 저장할 경우, 356을 넣어야 올바른 값을 얻을 수 있음
    
- 값을 넘어서는 방식으로 변환할 경우, 에러를 일으킴을 주의해야 함
    
- 데이터 타입의 네 가지 종류를 숫자로 변환해봄
    
- 배열에 0부터 9까지의 정수형 자료를 넣는 연습을 해봄
    
- 복소수 타입에 1과 1의 실수를 넣고, 자료형이 복소수 타입으로 형성됨
    

16-3.배열과 메모리

- 원본 데이터를 유지하면서 메모리에 복사하는 방식임을 이해함
    
- 메모리에 저장된 복사본과 원본 데이터는 다를 수 있음을 인지함
    
- 임의의 실수형 자료를 메모리에 저장하고, 임의의 허수형 자료를 추가함
    
- 메모리에 저장된 복사본과 원본 데이터를 비교하여, 데이터 저장 방식을 이해함
    

17.배열과 행렬

17-1.배열과 행렬의 차이

- 값의 크기와 방향을 함께 가진 데이터를 행렬이라고 부름
    
- 행렬은 열 또는 행으로 이루어져 있고, 값의 크기가 방향과 함께 결정됨
    
- 0, 1, 2, 3 순서대로 값의 크기가 커지는 벡터는 행벡터라고 부름
    
- 행렬의 반대 벡터인 열벡터는 열의 방향과 반대 방향으로 변함
    
- 벡터의 차원은 배열의 차원에 따라 다름 (행벡터, 열벡터, 텐서, 다차원 텐서)
    

17-2.배열과 행렬의 연산

- 배열의 연산은 일괄 처리를 위해 N개를 사용하여 연산을 수행함
    
- 벡터의 연산은 0, 1 벡터를 만든 후, 특정 위치의 값을 변경하여 사용함
    
- 벡터 간의 연산을 할 때는 0, 1 벡터를 만든 후, 입력 데이터를 활용하여 연산을 수행함
    
- 0벡터와 1벡터를 생성하는 함수는 제로스와 어레인지임
    
- 초기값을 만들어 놓고 특정 연산을 수행하는 방법도 있음
    

17-3.행렬의 초기값과 연산

- 행렬의 초기값은 차원에 따라 다르게 초기화됨 (행벡터, 열벡터, 텐서, 다차원 텐서)
    
- 벡터의 초기값을 설정할 때, 간단한 연산을 위해 차원의 개수로 초기값을 결정할 수 있음
    
- C 언어로는 벡터의 초기값을 3행 2열짜리 0벡터로 만들 수 있음
    
- 행렬의 초기값을 설정할 때, 원소가 많은 경우 일부만 선택하여 초기값을 설정할 수 있음
    

18.넘파이 설치 및 활용

18-1.넘파이 설치 및 기본 연산 이해

- 넘파이는 파이썬 공식 문서에 포함되어 있지 않으므로, 직접 확인해야 함
    
- 0벡터와 1벡터 생성 연산은 직접적으로 0과 1을 넣는 것이 아닌, 넘파이의 랜덤 모듈을 사용하여 생성함
    
- 더미 데이터를 가지고 직접 값을 넣는 대신, 넘파이의 랜덤 모듈을 사용하여 랜덤 패턴을 생성하여 배열에 삽입할 수 있음
    
- 랜덤 모듈은 파이썬 공식 문서에서 확인하거나, 직접 검색하여 사용할 수 있음
    
- 사용 방법은 "기본 연산" 메뉴에서 확인 가능하며, 이 외에 다른 연산들을 추가적으로 확인할 수 있음
    

18-2.넘파이의 API 참조

- 넘파이의 API는 "API 참조" 메뉴에서 확인 가능하며, 여기에는 다양한 동작에 대한 API 정보가 정리되어 있음
    
- 내장 함수의 사용 방법과 함께, 함수별로 필요한 데이터 형식 등 다양한 정보를 확인할 수 있음
    
- 예를 들어, "아이브리드곱근" 함수의 경우, "아이브리드곱근"이 무엇을 의미하는지, 어떤 데이터 형식을 갖는지 등을 확인할 수 있음
    
- 이 메뉴에서는 각 함수의 사용 방법을 설명하는 API 참조를 통해, 함수의 기본 정보를 알 수 있음
    

18-3.구체적인 사용 방법

- "구체적인 사용 방법" 메뉴에서는 함수의 사용 방법에 대해 더욱 자세히 설명함
    
- 사용 방법은 직접 코드 작성하는 것이 아니라, 메뉴에서 제공하는 예제 코드를 참조하는 것임
    
- 예제 코드를 통해, 함수를 어떻게 사용해야 하는지 한 단계씩 자세히 설명함
    
- 이 메뉴에서 제공하는 코드의 실행 결과와 함께, 올바른 사용 방법에 대해 설명함
    
- 사용 방법에 대한 자세한 내용은 해당 메뉴에서 확인 가능하며, 이를 통해 함수의 사용 방법을 완벽하게 이해할 수 있음

1.랜덤분포

1-1.가우시안 분포

- 평균 근처의 데이터들이 대부분 평균 근처에 몰려있다는 사실을 이용하여 가우시안 분포를 정의함
    
- 자연 발생 데이터는 평균에서 몇 표준편차만큼 떨어져있다는 사실을 활용하여 정의함
    
- 현실 데이터에서 중복을 허용하지 않는 경우, 평균에서 얼마나 떨어져 있는지 판단하는 기준으로 활용 가능함
    
- 0에서 10 사이의 정수를 균등분포를 따르는 6개를 뽑아내는 랜덤 함수인 정규분포를 사용함
    
- 중복을 허용하지 않는 정수 6개를 뽑아내는 함수인 제트정규분포를 사용함
    

1-2.랜덤 함수

- 랜덤에 정규분포를 따르는 확률을 리턴하는 함수인 정규분포를 사용함
    
- 평균이 0이고 표준편차가 1인 정규분포에서 리턴하는 확률을 확인함
    
- 중복을 허용하지 않는 데이터를 수집하거나, 한번 데이터를 수집한 후 중복을 허용하지 않는 경우를 고려해야 함
    
- 랜덤 함수 중 하나인 스트랩스태그 함수를 사용하여, 중복을 허용하지 않는 정수 6개를 균등분포를 따르는 6개를 뽑아냄
    
- 스트랩스태그 함수는 데이터 수집 전에 중복을 허용하지 않는 경우를 고려하여 중복 없이 데이터를 수집함
    

1-3.데이터 처리

- 데이터를 수집하거나, 처리할 때 중복을 허용하지 않는 경우를 고려해야 함
    
- 중복을 허용하는 경우, 평균에서 몇 표준편차만큼 떨어져 있는지 판단하는 기준으로 활용 가능함
    
- 표준편차는 평균에서 음의 값이나 양의 값을 떼어내는 값임
    
- 정규분포에서 3표준편차 안에는 99.7% 정도의 데이터가 포함됨
    
- 수집한 데이터가 중복을 허용하지 않는 경우, 평균에서 얼마나 떨어져 있는지 판단하는 기준으로 활용 가능함
    

2.랜덤 모듈

2-1.랜덤 샘플 생성

- 랜덤 샘플을 생성하는 다양한 방법이 있음
    
- 무작위 샘플을 생성할 때 배열에 특정 값을 넣어 놓으면 복원 샘플이 되어 특정 값을 가질 확률이 됨
    
- 복원 샘플을 생성하는 방법은 '리플레이스' 파라미터를 사용하여 설정할 수 있음
    
- 복원 추출은 배열의 값을 그대로 사용하여 새로운 샘플을 만드는 방법임
    
- 비복원 추출은 새로운 샘플을 생성하지 않고 원래의 배열에서 지우는 방법임
    

2-2.선택과 중복 제거

- '게임 이론' 모듈에서 '게임 이론' 함수를 사용하여 선택과 중복 제거를 할 수 있음
    
- '게임 이론' 함수에 '도입'과 '설정' 파라미터를 넣어 사용할 수 있음
    
- '도입' 파라미터는 선택의 확률을, '설정' 파라미터는 샘플의 복원 여부를 의미함
    
- 선택 확률은 범위에 따라 다를 수 있고, 복원 여부는 균등하게 분포를 따르도록 설정할 수 있음
    
- '게임 이론' 모듈은 다양한 파라미터를 제공하여 선택과 추출을 통제할 수 있음
    

2-3.예외 처리와 모듈 사용

- 선택과 추출 시 예외 처리를 통해 오류를 미리 방지할 수 있음
    
- '리플레이스' 모듈은 '리플레이스' 파라미터를 사용하여 중복 제거 결과를 반환함
    
- 중복 제거 여부를 파라미터에 넣어 사용할 수 있고, '리플레이스' 모듈에서 직접 확인 가능함
    
- '모듈'이나 '패키지'를 사용할 때는 '모듈의 공식 문서'를 참조하여 사용해야 함
    
- 랜덤 모듈은 중복 제거와 선택에 대한 다양한 옵션을 제공하여 효율적인 활용이 가능함
    

3.통계적 분포를 활용한 데이터 분석 기법

3-1.균등분포를 이용한 데이터 분석

- 파이썬 모듈의 랜덤 모듈을 활용하여 동일한 값을 반복적으로 생성함
    
- 랜덤 모듈에서 시드 값을 조정하여 균등분포에 의한 값을 생성
    
- 시드 값을 변경한 두 개의 입력값에서 평균, 최대, 최소 값을 추출
    
- 분석 목표를 설정하고 이에 따라 각각 다른 시드 값으로 파이프라인 실행
    

3-2.시드값을 통한 데이터의 동일성 추정

- 랜덤 모듈을 통해 동일한 시드값이 주어진 경우, 확률적으로 동일한 결과를 가져옴
    
- 시드값의 한계를 정하고 이에 따른 분석 방법 결정
    
- 시드값의 결과로 생성된 데이터에서, 각각 다른 시드값에 따른 평균, 최대, 최소 값을 추출
    
- 추출된 값을 기반으로 새로운 파이프라인 생성
    

3-3.파이썬 모듈을 활용한 실질적인 분석

- 파이썬 모듈의 랜덤 함수를 활용하여 실질적인 분석 작업 진행
    
- 평균, 중앙값, 최빈값 등의 분석 지표를 추출하여 사용
    
- 시드값에 따라 생성된 데이터를 바탕으로 분석 지표를 설정
    
- 설정된 지표를 바탕으로 최종 분석 결과 도출
    

4.납수치 이해와 분석

4-1.평균과 중앙값 이해

- 결측치 보관 시 평균 사용을 추천함
    
- 결측치는 최빈값, 중앙값, 평균을 기준으로 채워 넣어야 함
    
- 값의 분포에 따라 기준값을 채우는 것이 중요함
    
- 온도 데이터를 예로 들어 설명함
    
- 10분마다 수집한 값을 기준으로 기준값을 산출하는 방법을 설명함
    

4-2.통계적 계산 메소드

- 평균, 중앙값, 최빈값을 구하는 네 가지 통계적 계산 메소드를 설명함
    
- 평균은 전체 데이터의 합을 전체 개수로 나눈 값임
    
- 중앙값은 값의 순서를 반영하여 정중앙에 있는 값을 구하는 방법임
    
- 최빈값은 본래 배열의 순서를 유지하며 최빈값을 구하는 방법임
    
- 스태티스틱스 모듈에서 최빈값을 구하는 OPT 함수를 사용할 수 있음
    

4-3.기타 통계적 계산 메소드

- 추가적으로 랜덤 분포를 지닌 값들을 가지고 평균을 구하는 방법이 있음
    
- 랜덤을 여러 번 반복하면 값의 평균이 일정해짐을 설명함
    
- 평균을 계산할 때 가중치를 부여하는 방법을 소개함
    
- 가중치를 부여하는 이유를 설명하며, 국어, 영어, 수학, 사탐 1, 2, 3의 예를 듬
    
- 가중치를 통해 평균을 보다 정확하게 계산할 수 있음을 강조함
    

5.랜덤과 평균

5-1.랜덤과 번호

- 랜덤을 통해 정수의 번호를 생성할 수 있음
    
- 랜덤의 중복을 방지하기 위해 시트구간을 사용함
    
- 랜덤에서 최댓값과 최솟값을 추출할 수 있음
    
- 시트구간을 이용한 정렬은 덧붙여 복원하는 과정이 필요 없음
    
- 정렬된 배열의 최댓값과 최솟값은 자주 사용되는 메서드인 '아그민'을 통해 찾을 수 있음
    

5-2.평균과 정수의 비교

- 실제 데이터의 평균은 전체 데이터의 크기를 개수로 나눈 값임
    
- 통계에서 평균은 '가중치'를 곱해 '최빈값'을 구하는 방법을 사용함
    
- '최빈값'은 가장 자주 등장하는 값이며, 이는 먼저 발견한 값임
    
- '가중치'를 사용하는 평균 계산은 '정규분포의 평균' 모듈에서 구할 수 있음
    
- 통계에서 '최빈값'을 찾는 것은 장점이 있음
    

5-3.솔트드 함수의 활용

- '솔트드'는 파이썬의 내장함수로, 결과를 배열로 반환함
    
- '솔트드'를 사용하면, 배열의 요소를 순서대로 정렬할 수 있음
    
- '위집정렬'을 원하면, '홀짝수' 파라미터를 true로 사용해야 함
    
- 결과를 돌려주지 않는다는 점이 차이점임
    
- 결과를 반환하지 않는 것은 '무조건 리터러블' 객체로 결과를 반환함을 의미함
    

6.넘파이의 배열과 데이터 처리 기능

6-1.넘파이의 배열과 데이터 처리 기능 개요

- 넘파이는 원본 데이터를 그대로 유지하며, 원본과 동일한 결과를 반환함
    
- 배열의 요소를 추가하거나 삭제하고, 배열의 길이를 변경하는 등의 데이터 처리 기능 제공
    
- 단순히 값을 삽입하거나 변경하는 것뿐 아니라, 배열의 초기값을 설정하거나 배열을 복사하는 등의 작업도 수행
    
- 복사 메소드는 원본 자체를 복사하여 새로운 배열에 삽입하는 기능을 제공
    
- 필요한 경우에 한 데이터를 삽입하거나 삭제하고, 배열의 길이를 변경하는 등 다양한 데이터 처리가 가능
    

6-2.넘파이의 솔트 메서드와 그 활용

- 솔트 메서드는 원본 데이터를 그대로 유지하면서, 특정 순서로 데이터를 정렬하는 기능 제공
    
- 이 기능을 이용하면 원본 데이터를 변경하지 않고, 정렬된 데이터를 반환받을 수 있음
    
- 메서드의 사용에 있어서, 원본 데이터의 변화를 최소화하여 복잡성을 줄임
    
- 결과를 반환하기 위해, 인스턴스 메서드와 다른 메서드가 동일한 동작을 하지만 결과의 순서가 다름
    
- 이 다름은 원본 데이터의 변화 없이 순서만 바꾸어 원하는 결과를 얻는 것을 목표로 함
    

6-3.슬라이싱 메서드와 그 활용

- 슬라이싱 메서드는 특정 위치부터 그대로 진행하는 메서드로, 공간의 특정 영역을 절단함
    
- 이 기능을 통해 배열의 일부를 절단하거나, 전체를 절단할 수 있으며, 처음부터 끝까지 또는 처음부터 끝까지를 모두 절단 가능
    
- 슬라이싱 메서드를 사용하면 아웃오브메모리 에러가 발생하지 않으며, 배열의 일부를 변경할 수 있음
    
- 결과를 반환하기 위해, 인스턴스 메서드와 슬라이싱 메서드가 동일한 동작을 하지만 결과의 순서만 다름
    
- 슬라이싱 메서드는 복잡성을 줄이고, 원본 데이터의 유지 및 복사가 가능하다는 점에서 유용하게 활용될 수 있음
    

7.슬라이싱과 인덱싱

7-1.슬라이싱과 인덱싱의 차이

- 슬라이싱과 인덱싱 모두 차원을 유지하지만, 슬라이싱은 차원을 그대로 유지, 인덱싱은 차원을 사라뜨림
    
- 슬라이싱은 아웃 오브 레인지 에러를 일으키지 않음
    
- 슬라이싱을 사용하면 특정 행이나 열을 지정하여 값을 떠올릴 수 있음
    
- 인덱싱은 특정 행이나 열의 값을 떠올리거나, 그 다음 열을 지정하여 값을 떠올릴 수 있음
    
- 슬라이싱은 행에만 특정 값이 존재할 때, 인덱싱은 열에만 특정 값이 존재할 때 사용함
    

7-2.슬라이싱과 인덱싱의 예

- 2차원 행렬에서 특정 열을 지정하여 값을 떠올리는 예제를 설명함
    
- 슬라이싱을 사용하여 특정 열을 지정하여 값을 떠올리면, 해당 열의 모든 값이 가져옴
    
- 인덱싱을 사용하여 열의 특정 부분만 지정하여 값을 떠올리면, 해당 부분의 값을 떠올리게 됨
    
- 인덱싱을 사용하면, 생략 가능한 부분은 행에만 지정 가능하지만, 열에 대해선 지정 불가함
    
- 값을 슬라이싱으로 떠올리면, 특정 열부터 해당 열의 모든 값을 포함한 결과가 나옴
    

7-3.행렬 연산 시 차원의 중요성

- 연산 시 차원이 중요한데, 행렬 연산에서는 슬라이싱이 차원을 유지하고, 인덱싱은 차원을 사라뜨림
    
- 슬라이싱을 사용하면, 2차원 행렬의 특정 열을 지정하여 해당 열의 모든 값을 떠올리게 됨
    
- 인덱싱을 사용하면, 특정 열의 일부만 지정하여 값을 떠올리면 해당 부분의 값을 떠올리게 됨
    
- 필요한 경우, 인덱싱을 사용하여 원하는 부분 집합을 만들 수 있음
    
- 행렬을 다 가져오지 않고 필요한 부분만 가져오면, 차원을 유지한 채 필요한 부분에 대한 값만 가져올 수 있음
    

8.행렬과 행렬 인덱싱의 활용

8-1.행렬의 특징과 사용

- 행렬은 3행 4열로 구성되어 있으며, 이를 이용해 원소를 검색함
    
- 대괄호 안에 조건을 작성하면, 행렬의 해당 원소만 선택하여 사용할 수 있음
    
- 이를 통해 원하는 특정 값을 고르는 작업을 간결하게 할 수 있음
    
- 이러한 인덱싱을 블린 인덱싱이라고 부름
    

8-2.블린 인덱싱의 메소드들

- 'where' 메소드는 특정 조건에 따라 값을 리턴함
    
- 'all' 메소드는 모든 원소에 대해 동일한 판단을 수행함
    
- 'any' 메소드는 하나라도 특정 조건을 만족하면 true, 그렇지 않으면 false를 리턴함
    
- '열 기준으로' 메소드는 특정 열에 따라 다른 가치를 반환함
    

8-3.행렬 인덱싱의 세부 기능

- '슬라이싱'은 행렬의 순서를 바꾸는 기능을 제공함
    
- '인덱싱'은 원하는 특정 값들만 추려내는 기능을 제공함
    
- '넘파이'에서는 두 가지 특별한 경우를 관리하며, 이에 따라 다른 방식으로 동작함
    
- 이 강의에서 다룬 내용을 이해하면, 실제 행렬 데이터를 처리하는 데 도움이 될 것임
    

9.넘파이 데이터 처리

9-1.넘파이 기본 개념 이해

- 넘파이는 행렬을 다루는 프로그래밍 언어임
    
- 메트로닉스는 실제 데이터를 내장형으로 숫자화한 것과 같음
    
- 메트로닉스에서 다룬 데이터 형태는 실제 데이터와 다름
    
- 메트로닉스에서 데이터의 불순물은 행렬 형태로 나타낼 수 있음
    
- 플롯 자료형은 거대한 수나 무한대를 다루는 경우에 사용됨
    

9-2.넘파이에서의 값 처리

- 값이 없을 때는 '나더 넘버'로, 값이 넘칠 때는 '인피닛'으로 처리함
    
- 나더 넘버와 인피닛은 값이 없는 경우를 모두 대상으로 하므로 일괄 처리가 가능함
    
- 한 개 이상의 업무를 수행할 때, 이런 처리가 브로드 캐스팅을 방해할 수 있음
    
- 특히, 업무 처리를 위한 열의 개수, 행의 개수, 열의 개등을 많이 가질 경우 더욱 그러함
    
- 따라서, 메트로닉스에서 값이 없음을 '나더 넘버'로 처리하는 경우가 많음
    

9-3.값의 처리 결과

- '나더 넘버'와 '인피닛'의 변환은 업무 처리의 편의성을 위해 자연스럽게 일어나는 현상임
    
- '나더 넘버'로 숫자를 변환하는 것은 더 큰 수를 처리하거나, 무한대를 치환하는 등의 작업을 수행할 때 필요함
    
- 반면, '인피닛'로 숫자를 변환하는 것은 큰 변화 없이, 특정 수 이하의 값을 갖는 수를 유지하는 것이 목적임
    
- 이러한 값의 처리 결과는 다음 작업이 잘 이루어지도록 함
    
- 따라서, 메트로닉스에서 값이 없음을 '나더 넘버'로 처리하는 경우가 많음
    

10.파이썬과 넘파이를 활용한 데이터 처리

10-1.넘파이와 파이썬의 차이와 이해

- 넘파이는 파이썬보다 데이터 처리에 편리하며, 더 많은 기능을 제공함
    
- 넘파이에서는 데이터를 특정 위치로 나눠 처리하며, 특정한 값들을 일괄 처리함
    
- 파이썬에서는 코드를 돌려 특정 값을 0으로 나눠 처리하며, 0으로 나눈다면 제로 디비전 에러를 발생시킴
    
- 넘파이는 수학적으로 무한한 값을 처리하며, 이는 "수학적으로 무한한 값을 의미함"이라고 설명됨
    
- 넘파이에서의 데이터 처리는 전체 데이터를 처리하는 것이 아니라, 일부에만 특수한 값들이 일괄적으로 들어있는 경우를 처리함
    

10-2.넘파이 함수를 이용한 데이터 처리

- 넘파이에서 제공하는 여러 함수를 사용하여 데이터를 처리하고 분석함
    
- 이 함수들은 이상치를 확인하거나 데이터의 수를 확인하는 등 다양한 기능을 제공함
    
- 또한, 나머지 값들에 대해 true를 반환하여, 이 값들을 확인함
    
- 데이터 처리에 있어서 이상치를 확인하는 것은 매우 중요하며, 이에 대한 함수들이 많이 제공됨
    
- 넘파이에서 제공하는 함수들은 값의 유무를 확인하거나, 값의 개수를 카운트하는 등의 작업을 수행함
    

10-3.넘파이에서의 데이터 복사와 그 영향

- 파이썬에서의 복사와 달리, 넘파이는 깊은 복사를 통해 데이터를 복사함
    
- 복사시에는 메모리 주소를 복사하는 것이 아니라, 깊은 복사를 통해 복사함
    
- 따라서, 원본 데이터를 복사하지 않고 새로운 메모리 공간에 복사함
    
- 복사시에는 복사된 데이터를 원본에서 참조하는 것이 아니라, 복사된 공간에서 편집이 이루어짐
    
- 따라서, 복사시에는 원본 데이터가 일부나 전체가 훼손될 수 있다는 것을 주의해야 함
    

11.인덱싱과 슬라이싱

11-1.인덱싱과 슬라이싱

- 배열의 위치를 나타내는 인덱싱과, 특정 위치로 이동하는 슬라이싱이 있음
    
- 인덱싱은 특정 위치의 값을 직접 가리키는 것이고, 슬라이싱은 메모리의 다른 부분을 참조하는 것임
    
- 인덱싱은 차원을 유지하여 원본을 훼손하지 않고, 슬라이싱은 차원을 줄여 원본을 훼손할 수 있음
    
- 슬라이싱을 사용할 때, 백업을 하여 나중에 수정하지 않도록 해야 함
    
- 배열을 인덱싱이나 슬라이싱으로 조회할 때, 특정 위치의 값을 끄집어내는 명령어가 있음
    

11-2.행렬의 인덱싱과 슬라이싱

- 행렬의 특정 위치를 인덱싱하거나 슬라이싱하여 값을 끄집어낼 수 있음
    
- 인덱싱은 해당 위치의 값을 직접 가리키는 것이고, 슬라이싱은 메모리의 다른 부분을 참조하여 값의 위치를 조정하는 것임
    
- 인덱싱과 슬라이싱 모두 중요한 기능이지만, 각각의 상황에 맞게 사용해야 함
    
- 인덱싱은 원본 배열의 위치를 유지하며, 슬라이싱은 원본 배열의 일부를 변경할 수 있음
    
- 슬라이싱을 사용할 때, 백업을 하여 나중에 수정하지 않도록 해야 함
    

11-3.배열의 인덱싱과 슬라이싱 연습

- 배열의 인덱싱과 슬라이싱을 연습문제로 다룸
    
- 3차원 행렬의 특정 위치를 인덱싱하여 값을 끄집어내는 연습을 함
    
- 행렬의 행을 나열하고, 특정 위치의 값을 찾는 명령어를 사용함
    
- 인덱싱과 슬라이싱을 이용하여 배열의 일부를 참조하는 방법을 익힘
    
- 복사 또는 저장을 위한 함수 사용법을 설명함
    

12.슬라이싱과 연산

12-1.슬라이싱의 개요

- 슬라이싱은 행렬을 특정 차원으로 만들어내는 연산임
    
- 차원을 맞춰 원하는 대로 연산을 통해 결과를 출력함
    
- 행렬의 특정 위치에 값을 삽입하거나 추가할 수 있음
    
- 데이터의 형상을 변경할 수 있으므로, 데이터를 정확하게 입력해야 함
    
- 인덱싱과 슬라이싱을 사용하여 원하는 위치에 값을 삽입할 수 있음
    

12-2.슬라이싱의 장단점

- 슬라이싱은 차원과 인덱싱, 슬라이싱을 통한 인덱싱을 막을 수 있음
    
- 인덱싱과 슬라이싱을 통해 원하는 값을 얻을 수 있음
    
- 행렬의 특정 위치에 값을 삽입하거나 추가하는 연산을 통해 결과를 얻을 수 있음
    
- 형변환이 가능한 자료형의 경우, 데이터를 정확하게 입력해야 함
    
- 데이터의 형상을 변경할 수 있으므로, 데이터를 정확하게 입력하는 것이 중요함
    

12-3.슬라이싱의 예

- A1에 값을 삽입하거나 인덱싱을 통해 원하는 값을 얻을 수 있음
    
- V스택 또는 H스택 명령어를 사용하여 필요한 위치에 값을 삽입할 수 있음
    
- 순서대로 튜플로 작성하여 원하는 위치에 값을 삽입할 수 있음
    
- 데이터의 패턴에 따라 순서대로 값이 추가되므로, H스택 명령어를 사용하여 호라이즌 스택으로 삽입할 수 있음
    
- 순서대로 데이터를 삽입하면, 순서대로 튜플로 작성되어 바로는 결과를 얻을 수 있음
    

13.Numpy를 이용한 데이터 처리

13-1.수직선 연산과 풀 연산

- Numpy에서 '수평으로' 연산을 할 때는 수직으로 값을 넣어야 함
    
- 열벡터로 값을 넣을 때는 'T' 명령어를 사용함
    
- '합치다'라는 연산은 'T' 명령어를 사용하며, 여기서는 순서대로 값을 받아서 덧붙임
    
- '값'을 'T' 명령어로 전달하는 연산을 '치환'이라고 함
    
- '트랜스포즈'라는 명령어로 행과 열의 위치를 바꿀 수 있음
    

13-2.Numpy의 다양한 함수

- '집합'은 두 개의 배열을 연결하는 함수임
    
- '삽입'은 어떤 배열에 값을 추가하는 연산임
    
- '콘케이트네이트'는 배열을 거꾸로 뒤집는 함수임
    
- '행렬'은 행렬을 뒤집어주는 역행렬로 변환하는 함수임
    
- '트랜스포즈'는 행과 열의 위치를 바꾸어 내부적으로 동작시킴
    

13-3.패키지 사용과 연산

- Numpy는 여러 패키지들을 만들어 데이터를 제어함
    
- '보통' 패키지는 일괄적으로 적용 가능한 연산을 제공함
    
- '간단히' 패키지는 비교, 대조, 논리 연산을 제공함
    
- '데이터' 패키지는 데이터 처리에 필요한 다양한 기능을 제공함
    
- '패키지 사용'을 통해 데이터 처리 능력을 향상시킬 수 있음