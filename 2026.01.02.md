[Day1. 환경설정 & 파이썬 프로그래밍 기초](https://www.notion.so/Day1-2d8efd73348980ecb103f79a78a433d0?pvs=21)

[https://colab.research.google.com/drive/1_1_1jbcWLKgeBjbLecgnlGVSve1b4g3c?usp=sharing](https://colab.research.google.com/drive/1_1_1jbcWLKgeBjbLecgnlGVSve1b4g3c?usp=sharing)

[https://colab.research.google.com/drive/1e6kYKPd31PwUakroARD_U_JcW9H4cqyb?usp=sharing](https://colab.research.google.com/drive/1e6kYKPd31PwUakroARD_U_JcW9H4cqyb?usp=sharing)

### **1. 파이썬 파일 종류와 특징**

- **PY 파일**: 코드가 순서대로 동작하는 interpreter 언어 파일, 모든 내용이 함께 메모리에 올라가 실행됨
- **ipynb 파일(Interactive Python Notebook)**: 코드셀 단위로 파이썬을 실행시키는 파일, 한 줄씩 인터프리터 동작 확인 가능

### **2. 파이썬 코드 작성 규칙 (PEP 가이드)**

- 들여쓰기: 4칸씩 이동 권장
- 코드 길이: 80자가 넘어가면 가독성을 위해 줄바꿈
- 줄바꿈 방법: 백슬래시($$$를 이용해 같은 코드 블록 내에서 줄 변경
- 연산자 위치: 연산자가 길게 늘어지는 경우 줄바꿈 시 연산자 이전에 줄바꿈하고 연산자를 다음 줄에 배치
- 함수/클래스 구분: 앞뒤로 엔터 두 칸으로 구분

### **3. 주피터/코랩 환경 사용법**

- **코드셀**: 파이썬 코드 실행을 위한 셀
- **텍스트셀**: 설명이나 주석을 작성하기 위한 셀
- **셀 명령어**: `!`로 시작하는 명령어는 리눅스 셀 명령어로 실행됨
- **특수 명령어**: `%` 또는 `%%`로 시작하는 명령어들은 주피터에서 특별한 기능 수행 (시간 측정, 파일 저장 등)

### **4. 파이썬의 변수**

- 변수, 메모리 주소, 값 사이의 관계는 네임 스페이스를 통해 별도 관리됨
- 값이 바뀌면 새로운 메모리 주소에 값이 저장되고 변수명과 메모리 주소가 1:1로 관리됨
- 변수명 규칙:
    - `_` 또는 `__`가 앞에 붙은 변수명: 직접 호출하지 않는 내부용 변수
    - 예약어(키워드): 변수명으로 사용 가능하지만 원래 기능 덮어쓰므로 주의
    - 네이밍 컨벤션: 일반 변수/함수는 snake_case, 클래스는 PascalCase 사용

### **5. 파이썬 자료형**

- **기본 자료형**:
    - 숫자: 정수(int), 실수(float), 불리언(bool)
    - 문자: 문자열(string)
    - 값 없음: None
- **집합 자료형**: 기본 자료형들의 모음을 담는 자료형

### **정수(int)**

- 기본 4바이트 할당하지만 큰 수 입력 시 자동으로 메모리 확장
- 변수 관리를 위한 오버헤드(overhead) 발생

### **실수(float)**

- 부동소수점 방식 사용 (소수점 위치가 고정되지 않음)
- 2의 n승으로 변환해 계산하므로 약간의 오차 발생
- 정밀한 계산이 필요할 때는 `decimal` 모듈 사용

### **불리언(bool)**

- `True` 또는 `False`로 표기, 내부적으로는 1과 0으로 변환
- 조건문과 반복문에서 조건 판별에 사용

### **문자열(string)**

- 한 글자건 여러 글자건 모두 string 자료형으로 관리
- 작은따옴표('), 큰따옴표("), 멀티라인 따옴표(''' 또는 """)로 표현
- 공백, 탭, 엔터는 각각 다른 값으로 처리됨
- 특수 문자 사용 시 이스케이프 문자(`\\`) 사용
- 문자열 그대로 사용하려면 로우 스트링(`r'문자열'`)으로 표현

### **None 타입**

- 값이 정해지지 않은 상태
- 플래그 변수로 많이 사용

### **6. 파이썬의 연산자**

### **산술 연산자**

- `+`: 덧셈
- : 뺄셈
- : 곱셈
- `/`: 나눗셈 (결과는 항상 float)
- `*`: 거듭제곱
- `%`: 나머지
- `//`: 몫

### **복합 대입 연산자**

- `+=`, `=`, `=`, `/=` 등
- 전위/후위 연산자(`++`, `-`)는 파이썬에 없음

### **비교 연산자**

- `==`: 값과 자료형이 모두 같은지 비교
- `!=`: 같지 않은지 비교
- `>`, `<`, `>=`, `<=`: 크기 비교
- 여러 개의 비교 연산자 연속 사용 가능 (ex: `1 < x < 10`)
- 집합 자료형도 비교 연산 가능

### **동일성 연산자**

- `is`: 메모리 주소까지 동일한지 확인
- `is not`: 메모리 주소가 다른지 확인

### **논리 연산자**

- `and`: 두 조건이 모두 True일 때 True 반환
- `or`: 두 조건 중 하나라도 True이면 True 반환
- `not`: 조건의 반대 값 반환
- 우선순위: `not` > `and` > `or`

### **연산자 우선순위**

1. 소괄호(`()`)
2. 제곱(`*`)
3. 음수 부호(`x`)
4. 곱셈, 나눗셈, 몫, 나머지(, `/`, `//`, `%`)
5. 덧셈, 뺄셈(`+`, )
6. 비교 연산자(`==`, `!=`, `>`, `<` 등)
7. 논리 연산자(`not` > `and` > `or`)

### **1. 연산자 우선순위**

- **논리 연산자 우선순위**: not > and > or 순서로 연산됨
- **단락 평가(Circuit Evaluation)**:
    - or 연산에서는 첫 번째 값이 True면 뒤의 값을 평가하지 않고 바로 해당 값 반환
    - 예시: `True or 4` → `True` 반환, `4 or True` → `4` 반환
    - 이를 활용한 기본값 설정: `weather = input("오늘 날씨는") or "입력 없음"`

### **2. 형변환**

- 실수에서 정수로 변환할 때는 소수점 이하가 버려짐: `int(13.5)` → `13`
- 데이터 손실을 최소화하려면 반올림 사용 권장: `round(13.5)`
- 웹에서 받은 실수 데이터를 정수로 변환: `int(float("3.16"))`
- **Boolean 형변환**:
    - False로 평가되는 값: 0, 빈 문자열(""), None, False, 빈 컬렉션([], {}, ())
    - 그 외의 모든 값은 True로 평가됨

### **3. 시퀀스형 자료구조**

### **A. 리스트(List)**

- **특징**: 가변 자료형, 원소의 내용 변경 가능
- **생성**: `li = [1, 2, 3, 4]`
- **인덱싱**: `li[0]` (인덱스는 0부터 시작)
- **음수 인덱싱**: `li[-1]` (마지막 원소부터 역순으로 접근)
- **주요 메서드**:
    - `append(x)`: 리스트 끝에 원소 추가
    - `extend([x, y, z])`: 리스트에 여러 원소 확장 추가
    - `insert(i, x)`: i 위치에 원소 삽입
    - `pop([i])`: 지정한 인덱스의 원소 제거 후 반환, 기본값은 마지막 원소
    - `remove(x)`: 첫 번째로 나타나는 x 값 제거
    - `clear()`: 모든 원소 제거
    - `reverse()`: 원소 순서 뒤집기
    - `sort()`: 원소 정렬

### **B. 튜플(Tuple)**

- **특징**: 불변 자료형, 한번 생성 후 내용 변경 불가
- **생성**: `tu = (1, 2, 3, 4)`
- **주의사항**: 원소가 하나인 튜플은 `(3,)`처럼 콤마 필요
- **사용 가능한 메서드**: 원본 변경이 필요 없는 `count()`, `index()` 만 사용 가능

### **C. 레인지(Range)**

- **특징**: 정수 시퀀스를 효율적으로 생성, 지연 평가(lazy evaluation) 사용
- **생성**:
    - `range(stop)`: 0부터 stop-1까지
    - `range(start, stop)`: start부터 stop-1까지
    - `range(start, stop, step)`: start부터 step 간격으로 stop-1까지
- **메모리 효율성**:
    - 실제 값 대신 생성 규칙만 저장해서 메모리 효율적
    - 예: `range(10000)`은 48바이트, `list(range(10000))`은 80,056바이트

### **4. 인덱싱과 슬라이싱**

- **인덱싱**: 특정 위치의 단일 요소 접근 (`sequence[i]`)
- **슬라이싱**: 부분 시퀀스 추출 (`sequence[start:stop:step]`)
    - 생략 가능: `sequence[:stop]`, `sequence[start:]`, `sequence[::step]`
    - 슬라이싱은 존재하지 않는 인덱스를 참조해도 IndexError가 발생하지 않음
    - 문자열에도 적용 가능: `"Yeongji's HOME"[0:4:3]`

### **5. 맵핑형 자료구조 - 딕셔너리(Dictionary)**

- **특징**: 키-값 쌍으로 데이터 저장, 해시 테이블 구조
- **생성**: `d = {'key1': 'value1', 'key2': 'value2'}`
- **접근**: `d['key1']`
- **주요 메서드**:
    - `keys()`: 모든 키 반환
    - `values()`: 모든 값 반환
    - `items()`: 모든 (키, 값) 쌍 반환
    - `get(key, default=None)`: 키가 있으면 값 반환, 없으면 기본값 반환
    - `setdefault(key, default=None)`: 키가 있으면 값 반환, 없으면 기본값으로 추가하고 반환
    - `update({key: value, ...})`: 여러 키-값 쌍 한번에 업데이트
    - `pop(key, default)`: 키에 해당하는 값 제거하고 반환, 키가 없으면 기본값 반환
- **키 중심 동작**: 딕셔너리의 대부분 메서드는 키를 기준으로 동작함
- **조회 속도**: 인덱스 대신 키로 직접 접근하여 조회 속도가 빠름

# **1. 딕셔너리(Dictionary)**

- **개념**: 중복을 피하기 위해 키-값 쌍으로 데이터를 저장하는 맵핑형 자료형
    
- **특징**:
    
    - 순서가 없는 자료형이지만 Python 3.7 이후부터는 내부적으로 순서를 기억함
    - 키는 중복될 수 없으며, 값에 접근할 때 키를 사용함
- **생성 방법**:
    
    python복사
    
    `my_playlist = {"K-pop": "Butter", "J-pop": "Dry Flower"} # 직접 생성my_playlist = {} # 빈 딕셔너리 생성 후 값 추가`
    
- **주요 메서드**:
    
    - `update()`: 여러 키-값 쌍을 한꺼번에 추가
    - `setdefault()`: 키가 있으면 해당 값 반환, 없으면 기본값 설정
    - `popitem()`: 마지막에 삽입된 키-값 쌍을 튜플로 반환하고 삭제

# **2. 세트(Set)**

- **개념**: 중복을 걸러내기 위한 자료형으로, 문패(키)만 가지고 있음
    
- **특징**:
    
    - 순서가 없는 자료형(인덱스로 접근 불가)
    - 중복된 값을 자동으로 제거함
- **생성 방법**:
    
    python복사
    
    `set1 = {1, 2, 3, 4, 4, 2, 1} # 결과: {1, 2, 3, 4}`
    
- **주요 메서드와 연산**:
    
    - `intersection()` 또는 `&`: 두 세트의 교집합
    - `difference()` 또는 : 두 세트의 차집합
    - `union()` 또는 `|`: 두 세트의 합집합
    - 활용법: 리스트에서 중복 제거를 위해 세트로 변환 후 다시 리스트로 변환

# **3. 파이썬의 복사 방식**

- **얕은 복사(Shallow Copy)**:
    
    - 기본 복사 방식으로 메모리 주소를 공유함
    - 원본 데이터 변경 시 복사본도 함께 변경됨
    
    python복사
    
    `b = arr # 얕은 복사: 같은 메모리 주소 공유`
    
- **깊은 복사(Deep Copy)**:
    
    - 값 자체를 새로운 메모리에 복사
    - 원본 데이터 변경해도 복사본은 영향 받지 않음
    
    python복사
    
    `import copydeep_arr = copy.deepcopy(arr) # 깊은 복사`
    
- **주의사항**:
    
    - 내장 파이썬에서는 원본 데이터 보존을 위해 `copy.deepcopy()` 사용 필요
    - NumPy, Pandas 등 데이터 관련 패키지의 `copy()`는 이미 깊은 복사로 구현되어 있음

# **4. 조건문**

### **4.1. if문**

- **기본 구조**:
    
    python복사
    
    `if 조건1: # 조건1이 참일 때 실행elif 조건2: # 조건2가 참일 때 실행else: # 모든 조건이 거짓일 때 실행`
    
- **다중 조건문**: `and`, `or`, `not` 연산자를 사용하여 복합 조건 생성
    
- **중첩 조건문**: if문 안에 다른 if문을 포함하는 구조
    
- **연산자 우선순위**: `not` > `and` > `or` (괄호로 명확하게 표현 권장)
    
- **주의사항**: 비트 연산자(`&`, `|`, `~`)를 논리 연산자 대신 사용하지 말 것
    

### **4.2. match-case문 (Python 3.10+)**

- **기본 구조**:
    
    python복사
    
    `match 변수: case 값1: # 값1과 일치할 때 실행 case 값2: # 값2와 일치할 때 실행 case _: # 어떤 case도 일치하지 않을 때 실행`
    
- **특징**:
    
    - 정확한 값 매칭에 적합 (범위보다는 특정 값 비교에 유용)
    - if-elif-else보다 복잡한 패턴 매칭에서 코드가 간결해짐
- **특수 패턴**:
    
    - `_`: 어떤 값이든 매칭 (else와 유사)
    - `|`: "또는" 조건 (e.g., `case "Y" | "y":`)
    - : 나머지 요소를 리스트로 캡처 (언패킹)
- **할당 표현식 활용**: 바다코끼리 연산자(`:=`)로 매칭과 동시에 값 할당 가능
    

# **5. 패킹과 언패킹**

- **언패킹**: 컬렉션을 개별 변수로 분해
    
    python복사
    
    `first, second, *others = [1, 2, 3, 4, 5] # first=1, second=2, others=[3, 4, 5]`
    
- **패킹**: 개별 값을 하나의 컬렉션으로 합치기
    
- **언더바(`_`) 활용**: 사용하지 않을 값을 무시할 때 활용
    
    python복사
    
    `first, _, *others = [1, 2, 3, 4, 5] # 두 번째 값은 무시`
    

# **사례/예시**

1. **딕셔너리를 활용한 플레이리스트 관리**:
    
    python복사
    
    `my_playlist = {"K-pop": "Butter", "J-pop": "Dry Flower"}my_playlist["Rock"] = "Bohemian Rhapsody"my_playlist.update({"Golden": "BTS"})last_added = my_playlist.popitem() # 마지막에 추가한 항목 제거 및 반환`
    
2. **세트를 활용한 교집합, 차집합, 합집합 연산**:
    
    python복사
    
    `set1 = {1, 2, 3, 4, 5}set2 = {1, 3, 4, 7, 8, 9, 10}
    
    # 교집합: {1, 3, 4}print(set1 & set2)
    
    # 차집합: {2, 5}print(set1 - set2)
    
    # 합집합: {1, 2, 3, 4, 5, 7, 8, 9, 10}print(set1 | set2)`
    
3. **얕은 복사와 깊은 복사 예시**:
    
    python복사
    
    `arr = [[100, 200, 201], [10, 20, 30]]
    
    # 얕은 복사arr2 = arr[:]arr3 = arr[1]
    
    # arr의 내부 값 변경이 arr2, arr3에도 영향을 줌arr[0][2] = 2002 # arr2[0][2]와 arr3[2]도 변경됨
    
    # 깊은 복사import copydeep_arr = copy.deepcopy(arr)arr[0][2] = 3003 # deep_arr은 영향 받지 않음`
    
4. **중첩 조건문을 활용한 로그인 검증**:
    
    python복사
    
    `user_id = "admin"user_password = "1234" input_id = input("ID 입력: ")input_password = input("비밀번호 입력: ") if user_id == input_id: if user_password == input_password: print("로그인 되셨습니다.") else: print("비밀번호가 틀렸습니다.")else: print("로그인을 다시 시도하세요.")`
    
5. **match-case를 활용한 좌표 점 분류**:
    
    python복사
    
    `point = (0, 5) match point: case (0, 0): print("원점입니다.") case (x, 0): print("x축 위의 점입니다.") case (0, y): print("y축 위의 점입니다.") case (x, y): print(f"좌표상에 {x}, {y}에 위치해 있습니다.")`