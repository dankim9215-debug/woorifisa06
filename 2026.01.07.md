https://colab.research.google.com/drive/1gzJ0Y7uS86YAcK_XkbYW-O75fRG6LetM?usp=sharing
https://colab.research.google.com/drive/1olVrrAL__JMK3nGRKAgNI6zP-hkTHQTJ?usp=sharing
### 1. 함수(Function)

- **함수의 정의**: 재사용 가능한 코드 블록으로, `def` 키워드를 사용하여 정의
- **함수의 종류**:
    - 입력과 출력이 모두 없는 함수
    - 입력만 있고 출력이 없는 함수
    - 출력만 있고 입력이 없는 함수
    - 입력과 출력이 모두 있는 함수
- **파라미터와 인자**:
    - 파라미터(Parameter): 함수 정의 시 사용되는 변수
    - 인자(Argument): 함수 호출 시 실제로 전달되는 값
- **기본 파라미터**: 함수 호출 시 값을 제공하지 않으면 기본값이 사용됨
- **위치 인자(Positional arguments)**: 순서에 따라 전달되는 인자
- **키워드 인자(Keyword arguments)**: 이름을 명시하여 전달하는 인자
- **가변 인자**:
    - `*args`: 여러 개의 위치 인자를 튜플로 받음
    - `**kwargs`: 여러 개의 키워드 인자를 딕셔너리로 받음
- **타입 힌트(Type Hints)**: 함수의 인자와 반환값의 자료형을 명시 (강제성은 없음)
- **전역변수와 지역변수**:
    - 지역변수: 함수 내에서만 사용, 함수 종료 시 사라짐
    - 전역변수: 함수 외부에서도 접근 가능, `global` 키워드로 함수 내에서 정의 가능

### 2. 재귀함수(Recursive Function)

- **개념**: 자기 자신을 호출하는 함수
- **특징**:
    - 복잡한 문제를 단순한 코드로 해결 가능
    - 종료 조건이 필요함 (무한 재귀 방지)
- **활용**:
    - 팩토리얼 계산
    - 리스트 평탄화(flatten) 등

### 3. 람다함수(Lambda Function)

- **정의**: 이름 없이 한 줄로 정의되는 익명 함수
- **문법**: `lambda 파라미터: 표현식`
- **활용**:
    - 정렬 시 key 함수로 사용
    - 함수형 프로그래밍에서 활용

### 4. 데코레이터(Decorator)

- **개념**: 함수를 감싸서 기능을 확장하는 문법
- **문법**: `@데코레이터_이름`
- **활용**:
    - 코드 재사용성 향상
    - 로그 기록, 실행 시간 측정 등 공통 기능 추가

### 5. 함수형 프로그래밍

- **특징**:
    - 동일 입력에 대해 항상 동일 출력 보장
    - 지연 평가(lazy evaluation) 사용
    - 상태 변경 최소화
- **주요 함수**:
    - **map()**: 각 요소에 함수 적용
    - **filter()**: 조건에 맞는 요소만 필터링
    - **reduce()**: 요소들을 누적하여 하나의 결과 생성
- **컴프리헨션(Comprehension)**:
    - **리스트 컴프리헨션**: `[표현식 for 항목 in 반복가능객체 if 조건]`
    - 딕셔너리, 집합 컴프리헨션도 가능

### 6. 제너레이터(Generator)

- **개념**: 값을 필요할 때마다 생성하는 이터러블 객체
- **특징**:
    - 메모리 효율적 (한 번에 하나의 값만 생성)
    - 대용량 데이터 처리에 유용

### 7. 파일 입출력

- **파일 열기**: `open(파일명, 모드)`
    - 읽기 모드: `'r'`
    - 쓰기 모드: `'w'`
    - 추가 모드: `'a'`
    - 바이너리 모드: `'b'` (읽기: `'rb'`, 쓰기: `'wb'`)
- **주요 메서드**:
    - `read()`: 전체 파일 내용 문자열로 읽기
    - `readline()`: 한 줄씩 읽기
    - `readlines()`: 모든 줄을 리스트로 읽기
    - `write()`: 파일에 쓰기
    - `close()`: 파일 닫기
- **with 구문**: 파일 사용 후 자동으로 닫아줌
    
    python복사
    
    with open(파일명, 모드) as 파일객체:
    
        # 파일 작업
    
- **플러시(flush)**: 버퍼에 있는 데이터를 즉시 파일에 쓰게 함 (기본값: False)

### 8. 문자열 처리

- **주요 메서드**:
    - `split(구분자, 개수)`: 문자열을 구분자를 기준으로 나눔
    - `replace(old, new, count)`: 문자열 치환
    - `strip([chars])`: 문자열 앞뒤의 공백 또는 지정 문자 제거
    - `lstrip([chars])`, `rstrip([chars])`: 왼쪽/오른쪽 공백 제거

## 강조사항

- 함수는 동작을 묶어 재사용성을 높이는 핵심 도구임
- 전역변수보다 지역변수 사용을 권장 (코드 관리 및 유지보수 용이)
- 재귀함수 사용 시 종료 조건 설정이 중요함
- 대용량 데이터 처리 시 제너레이터, 함수형 프로그래밍 기법 활용이 효율적
- 파일 작업 시 `with` 구문 사용을 권장 (파일 닫기 자동화)
- 문자열 처리는 내장 메서드를 활용하면 효율적으로 처리 가능

## 사례/예시

1. **함수 활용 예시**:
    
    python복사
    
    def reverse_list(lst):
    
        return lst[::-1]
    
2. **재귀함수 예시** (팩토리얼):
    
    python복사
    
    def factorial(n):
    
        if n <= 1:
    
            return 1
    
        return n * factorial(n-1)
    
3. **함수형 프로그래밍 예시**:
    
    python복사
    
    # 리스트 컴프리헨션
    
    [x+1 for x in range(10)]
    
    # map 활용
    
    list(map(lambda x: x+10, [1, 2, 3, 4, 5]))
    
    # filter 활용
    
    list(filter(lambda x: x % 3 == 0, range(10)))
    
4. **파일 입출력 예시**:
    
    python복사
    
    with open('test.txt', 'w') as f:
    
        f.write('Hello\n')
    
        f.write('World')
    
    with open('test.txt', 'r') as f:
    
        content = f.read()

### 1. 문자열 메소드

#### join 함수

- split의 반대 개념으로, 분리된 항목들을 하나로 합치는 역할
- 사용법: `구분자.join(반복가능한객체)`
- 예시: `"*".join(["짱구", "짱아", "장구", "엄마", "아빠"])` → "짱구_짱아_장구_엄마_아빠"
- 주의사항: join의 인자는 문자열 요소로 구성되어 있어야 함 (숫자 등은 str() 변환 필요)

python복사

# 숫자 리스트를 join할 경우 문자열 변환 필요

values = dict.values()  # [1,2,3,4,3,5,6]

" ".join(map(str, values))  # "1 2 3 4 3 5 6"

### 2. 텍스트 데이터 전처리

#### 문자열 전처리 기본 기법

- 대소문자 통일: `string.lower()` 또는 `string.upper()`
- 특수문자 제거: `string.replace("(", "")`, `string.replace(")", "")`
- 줄임말 처리: `string.replace("don't", "do not")`, `string.replace("can't", "can not")`

#### 단어 빈도 분석

1. 텍스트 전처리 (소문자 변환, 특수문자 제거)
2. 단어 분리 (split)
3. 단어별 빈도 카운팅

python복사

# 단어 빈도 카운팅 방법 1: 딕셔너리 활용

count_dict = {}

for word in words:

    if word in count_dict:

        count_dict[word] += 1

    else:

        count_dict[word] = 1

# 빈도 상위 10개 단어 출력

sorted(count_dict.items(), key=lambda x: x[1], reverse=True)[:10]

python복사

# 단어 빈도 카운팅 방법 2: collections 모듈 활용

import collections

counter = collections.Counter(words)

counter.most_common(10)  # 빈도 상위 10개 단어

### 3. 문자열 검색 메소드: find

- 문자열 내에서 특정 부분 문자열의 위치를 찾는 메소드
- 사용법: `string.find(찾을문자열, 시작위치, 끝위치)`
- 반환값: 첫 번째로 발견된 위치의 인덱스, 없으면 -1 반환
- 특징: 대소문자를 구분함
- 제한사항: 패턴 매칭이 불가능하여 정확한 문자열만 검색 가능

python복사

str1 = "IT AI engineering engineer gear"

str1.find("AI")  # 3

str1.find("ai")  # -1 (대소문자 구분)

str1.find("AI", 4)  # 6 (4번 인덱스 이후부터 검색)

### 4. 정규식(Regular Expression)

#### 정규식 기본 개념

- 특정 패턴을 가진 문자열을 검색, 치환하기 위한 형식 언어
- 파이썬에서는 `re` 모듈을 통해 사용

#### 정규식 기본 패턴

- `^` : 문자열 시작
- `$` : 문자열 끝
- `*` : 0개 이상 반복
- `+` : 1개 이상 반복
- `?` : 0개 또는 1개
- `[]` : 문자 클래스 (괄호 안의 문자 중 하나와 일치)
- `[a-z]` : a부터 z까지의 모든 소문자
- `[A-Z]` : A부터 Z까지의 모든 대문자
- `[0-9]` : 0부터 9까지의 모든 숫자
- `\d` : 숫자 [0-9]와 동일
- `\D` : 숫자가 아닌 문자
- `\w` : 단어 문자 (알파벳, 숫자, 언더스코어)
- `\W` : 단어 문자가 아닌 문자
- `\s` : 공백 문자
- `\S` : 공백이 아닌 문자

#### 파이썬에서 정규식 사용하기

python복사

import re

# 정규식 패턴 컴파일

pattern = re.compile(r'[a-zA-Z]+')  # 알파벳으로 이루어진 단어

# 문자열에서 패턴 찾기

result = pattern.findall("IT AI 엔지니어링 123 가나다")

print(result)  # ['IT', 'AI']

# 플래그 사용 (대소문자 무시)

pattern = re.compile(r'h[a-z]+', re.IGNORECASE)

pattern.findall("Happy happiness HAPPY")  # ['Happy', 'happiness', 'HAPPY']

# 멀티라인 모드

pattern = re.compile(r'^happy', re.MULTILINE | re.IGNORECASE)

pattern.findall("Hello\nHappy\nWorld")  # ['Happy']

#### 주요 정규식 메소드

1. `re.compile(pattern, flags=0)`: 정규식 패턴 컴파일
2. `pattern.match(string)`: 문자열의 처음부터 패턴과 일치하는지 검사
3. `pattern.search(string)`: 문자열 전체에서 패턴과 일치하는 첫 부분 검색
4. `pattern.findall(string)`: 패턴과 일치하는 모든 부분 리스트로 반환
5. `pattern.finditer(string)`: 패턴과 일치하는 모든 부분을 이터레이터로 반환
6. `re.sub(pattern, repl, string)`: 패턴과 일치하는 부분을 replacement로 대체

#### 이름 가리기 예제 (정규식 활용)

python복사

import re

def mask_name(name):

    if len(name) == 2:

        return re.sub(r'(\w)(\w)', r'\1*', name)

    else:

        return re.sub(r'(\w)(\w+)(\w)', r'\1' + '*' * len(name[1:-1]) + r'\3', name)

print(mask_name("김숙"))  # 김*

print(mask_name("김장구"))  # 김*구

print(mask_name("짱짱맨"))  # 짱**맨